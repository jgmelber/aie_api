<!-- SPDX-License-Identifier: MIT -->
<!-- Copyright (C) 2022 Xilinx, Inc. -->
<!-- Copyright (C) 2022-2024 Advanced Micro Devices, Inc. -->
<!-- HTML header for doxygen 1.9.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AI Engine API User Guide: Matrix Multiplication</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tables.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow" style="height: 60px">
  <td id="projectlogo" style="vertical-align: middle; padding-left: 15px; padding-right: 30px"><img height="32" alt="Logo" src="amd-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">AI Engine API User Guide<span id="projectnumber">&#160;(AIE-API)           2025.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group__mmul.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle"><div class="title">Matrix Multiplication</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>The AIE API encapsulates the matrix multiplication functionality in the <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a> class template. </p>
<p>This class template is parametrized with the matrix multiplication shape (MxKxN), the data types and, optionally, the requested accmululation precision. The resulting class defines a function that performs the multiplication and a data type for the result that can be converted to an accumulator/vector. The function interprets the input vectors as matrices as described by the shape parameters.</p>
<p>The following code snippet shows a portable sample blocked multiplication using the <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a> class. The matrices are assumed to be pre-tiled as defined by the mmul shape (MxK for A, KxN for B, and MxN for C).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">unsigned</span> M, <span class="keywordtype">unsigned</span> K, <span class="keywordtype">unsigned</span> N&gt;</div>
<div class="line"><span class="keywordtype">void</span> mmul_blocked(<span class="keywordtype">unsigned</span> rowA, <span class="keywordtype">unsigned</span> colA, <span class="keywordtype">unsigned</span> colB,</div>
<div class="line">                  <span class="keyword">const</span> <a class="code hl_typedef" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a> * __restrict pA, <span class="keyword">const</span> <a class="code hl_typedef" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a> * __restrict pB, <a class="code hl_typedef" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a> * __restrict pC)</div>
<div class="line">{</div>
<div class="line">   <span class="keyword">using </span>MMUL = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::mmul&lt;M, K, N, int16, int16&gt;</a>;</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> z = 0; z &lt; rowA; z += 2) chess_loop_range(2,) {</div>
<div class="line">       <a class="code hl_typedef" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a> * __restrict pC1 = pC + (      z * colB +       0) * MMUL::size_C;</div>
<div class="line">       <a class="code hl_typedef" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a> * __restrict pC2 = pC + ((z + 1) * colB +       0) * MMUL::size_C;</div>
<div class="line"> </div>
<div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = 0; j &lt; colB; j += 2) chess_loop_range(2,) {</div>
<div class="line">           <span class="keyword">const</span> <a class="code hl_typedef" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a> * __restrict pA1 = pA + (      z * colA +       0) * MMUL::size_A;</div>
<div class="line">           <span class="keyword">const</span> <a class="code hl_typedef" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a> * __restrict pA2 = pA + ((z + 1) * colA +       0) * MMUL::size_A;</div>
<div class="line">           <span class="keyword">const</span> <a class="code hl_typedef" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a> * __restrict pB1 = pB + (      0 * colB +       j) * MMUL::size_B;</div>
<div class="line">           <span class="keyword">const</span> <a class="code hl_typedef" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a> * __restrict pB2 = pB + (      0 * colB + (j + 1)) * MMUL::size_B;</div>
<div class="line"> </div>
<div class="line">           <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::vector&lt;int16, MMUL::size_A&gt;</a> A0 = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::load_v&lt;MMUL::size_A&gt;</a>(pA1); pA1 += MMUL::size_A;</div>
<div class="line">           <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::vector&lt;int16, MMUL::size_A&gt;</a> A1 = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::load_v&lt;MMUL::size_A&gt;</a>(pA2); pA2 += MMUL::size_A;</div>
<div class="line">           <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::vector&lt;int16, MMUL::size_B&gt;</a> B0 = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::load_v&lt;MMUL::size_B&gt;</a>(pB1); pB1 += MMUL::size_B * colB;</div>
<div class="line">           <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::vector&lt;int16, MMUL::size_B&gt;</a> B1 = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::load_v&lt;MMUL::size_B&gt;</a>(pB2); pB2 += MMUL::size_B * colB;</div>
<div class="line"> </div>
<div class="line">           MMUL C00; C00.mul(A0, B0);</div>
<div class="line">           MMUL C01; C01.mul(A0, B1);</div>
<div class="line">           MMUL C10; C10.mul(A1, B0);</div>
<div class="line">           MMUL C11; C11.mul(A1, B1);</div>
<div class="line"> </div>
<div class="line">           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 1; i &lt; colA; ++i) chess_prepare_for_pipelining chess_loop_range(3,) {</div>
<div class="line">               A0 = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::load_v&lt;MMUL::size_A&gt;</a>(pA1); pA1 += MMUL::size_A;</div>
<div class="line">               A1 = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::load_v&lt;MMUL::size_A&gt;</a>(pA2); pA2 += MMUL::size_A;</div>
<div class="line">               B0 = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::load_v&lt;MMUL::size_B&gt;</a>(pB1); pB1 += MMUL::size_B * colB;</div>
<div class="line">               B1 = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::load_v&lt;MMUL::size_B&gt;</a>(pB2); pB2 += MMUL::size_B * colB;</div>
<div class="line"> </div>
<div class="line">               C00.mac(A0, B0);</div>
<div class="line">               C01.mac(A0, B1);</div>
<div class="line">               C10.mac(A1, B0);</div>
<div class="line">               C11.mac(A1, B1);</div>
<div class="line">           }</div>
<div class="line"> </div>
<div class="line">           <a class="code hl_function" href="group__group__memory.html#gaa134a9db67641fc7ee69be78c7b00bf6">aie::store_v</a>(pC1, C00.template to_vector&lt;int16&gt;()); pC1 += MMUL::size_C;</div>
<div class="line">           <a class="code hl_function" href="group__group__memory.html#gaa134a9db67641fc7ee69be78c7b00bf6">aie::store_v</a>(pC1, C01.template to_vector&lt;int16&gt;()); pC1 += MMUL::size_C;</div>
<div class="line">           <a class="code hl_function" href="group__group__memory.html#gaa134a9db67641fc7ee69be78c7b00bf6">aie::store_v</a>(pC2, C10.template to_vector&lt;int16&gt;()); pC2 += MMUL::size_C;</div>
<div class="line">           <a class="code hl_function" href="group__group__memory.html#gaa134a9db67641fc7ee69be78c7b00bf6">aie::store_v</a>(pC2, C11.template to_vector&lt;int16&gt;()); pC2 += MMUL::size_C;</div>
<div class="line">       }</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group__memory_html_gaa134a9db67641fc7ee69be78c7b00bf6"><div class="ttname"><a href="group__group__memory.html#gaa134a9db67641fc7ee69be78c7b00bf6">aie::store_v</a></div><div class="ttdeci">T1 * store_v(T1 *ptr, const vector&lt; T2, Elems &gt; &amp;v)</div><div class="ttdoc">Store a vector of Elems size whose elements have type T.</div><div class="ttdef"><b>Definition</b> aie.hpp:740</div></div>
<div class="ttc" id="anamespaceaie_html_a43a139787b463ec1b70e6d1e25621808"><div class="ttname"><a href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::op_result_type_t</a></div><div class="ttdeci">typename op_result_helper&lt; T, Op &gt;::type op_result_type_t</div><div class="ttdef"><b>Definition</b> expr.hpp:349</div></div>
<div class="ttc" id="atypes_8hpp_html_aa918a75369e273ba410b034cd2ced87b"><div class="ttname"><a href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a></div><div class="ttdeci">int16_t int16</div><div class="ttdef"><b>Definition</b> types.hpp:21</div></div>
</div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:structaie_1_1mmul" id="r_structaie_1_1mmul"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul&lt; M_Elems, K_Elems, N_Elems, TypeA, TypeB, AccumTag &gt;</a></td></tr>
<tr class="memdesc:structaie_1_1mmul"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that encapsulates a blocked matrix multiplication C = A x B.  <a href="group__group__mmul.html#structaie_1_1mmul">More...</a><br /></td></tr>
<tr class="separator:structaie_1_1mmul"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>


<h3><a id="group_mmul_page_supported_modes" name="group_mmul_page_supported_modes"></a>Matrix Multiplication Modes</h3><div class="textblock"><h4><a class="anchor" id="group_mmul_page_supported_regular_modes"></a>
Supported Matrix Multiplication Modes</h4>
<table class="doxtable">
<caption>Matrix multiplication modes for real types</caption>
<tr>
<th>Arch.</th><th>8b x 4b</th><th>8b x 8b</th><th>16b x 8b</th><th>8b x 16b</th><th>16b x 16b</th><th>32b x 16b</th><th>16b x 32b</th><th>32b x 32b<sup>c</sup> </th><th>bfloat16 x bfloat16 </th><th>float x float<sup>d</sup> </th><th>bfp16 x bfp16 </th></tr>
<tr>
<td style="white-space: nowrap;">AIE </td><td style="vertical-align:top"></td><td style="vertical-align:top">4x8x4<br  />
 4x16x4<sup>a</sup><br  />
 8x8x4<sup>a</sup><br  />
 2x8x8<br  />
 4x8x8<sup>a</sup><br  />
 1x16x8<br  />
 2x16x8<sup>a</sup><br  />
 4x16x8<sup>a</sup> </td><td style="vertical-align:top">4x4x4<br  />
 8x4x4<sup>a</sup><br  />
 4x8x4<sup>a</sup><br  />
 4x4x8<sup>a</sup> </td><td style="vertical-align:top">4x4x8<sup>a</sup><br  />
 4x4x4<sup>a</sup><br  />
 8x8x1<sup>ab</sup> </td><td style="vertical-align:top">4x4x4<sup>a</sup><br  />
 2x4x8<sup>a</sup><br  />
 4x4x8<sup>a</sup><br  />
 4x2x8<sup>a</sup><br  />
 8x8x1<sup>ab</sup> </td><td style="vertical-align:top">2x4x8<sup>a</sup><br  />
 4x4x4<sup>a</sup><br  />
 4x2x4<sup>a</sup><br  />
 2x2x4<br  />
 2x4x4<sup>a</sup><br  />
 4x4x2<sup>a</sup><br  />
 2x2x8<sup>a</sup> </td><td style="vertical-align:top">4x2x2<br  />
 2x4x8<sup>a</sup><br  />
 4x4x4<sup>a</sup> </td><td style="vertical-align:top">4x2x4<sup>a</sup><br  />
 2x2x2<br  />
 2x4x2<sup>a</sup><br  />
 2x8x2<sup>a</sup><br  />
 4x2x2<sup>a</sup><br  />
 4x4x2<sup>a</sup><br  />
 2x4x4<sup>a</sup><br  />
 4x4x1<sup>a</sup> </td><td style="vertical-align:top"></td><td style="vertical-align:top">4x2x4<sup>a</sup><br  />
 2x2x2<sup>a</sup><br  />
 2x4x2<sup>ab</sup><br  />
 2x8x2<sup>ab</sup><br  />
 4x2x2<sup>a</sup><br  />
 4x4x2<sup>a</sup><br  />
 2x4x4<sup>a</sup><br  />
 4x4x1<sup>ab</sup> </td><td style="vertical-align:top"></td></tr>
<tr>
<td style="white-space: nowrap;">AIE-ML/XDNA 1 </td><td style="vertical-align:top">4x16x8<br  />
8x16x8<sup>a</sup><br  />
4x32x8<sup>ab</sup> </td><td style="vertical-align:top">4x8x4<sup>ab</sup><br  />
 4x16x4<sup>ab</sup><br  />
 8x8x4<sup>ab</sup><br  />
 2x8x8<br  />
 4x8x8<br  />
 8x8x8<sup>a</sup><br  />
 1x16x8<sup>ab</sup><br  />
 2x16x8<sup>ab</sup><br  />
 4x16x8<sup>ab</sup> </td><td style="vertical-align:top">4x4x4<sup>ab</sup><br  />
 8x4x4<sup>ab</sup><br  />
 4x8x4<br  />
 4x4x8 <br  />
 8x4x8<sup>ab</sup><br  />
 2x8x8 </td><td style="vertical-align:top">4x4x8<sup>ab</sup><br  />
 4x4x4<sup>ab</sup> </td><td style="vertical-align:top">4x4x4<br  />
 2x4x8<br  />
 4x4x8<sup>ab</sup><br  />
 4x2x8<br  />
 8x2x8<sup>a</sup><br  />
 8x1x8<sup>ab</sup> </td><td style="vertical-align:top">2x4x8<br  />
 4x4x8<sup>ab</sup><br  />
 4x4x4<br  />
 4x2x4<br  />
 4x1x8<sup>ab</sup> </td><td style="vertical-align:top">2x4x8<br  />
 4x4x4 </td><td style="vertical-align:top">4x2x4<sup>a</sup><br  />
 4x4x4<sup>ab</sup><br  />
 8x2x4<sup>a</sup><br  />
 4x1x8<sup>ab</sup><br  />
 8x1x8<sup>ab</sup> </td><td style="vertical-align:top">4x8x4<br  />
 8x8x4<sup>a</sup><br  />
 4x16x8<sup>ab</sup><br  />
 8x8x8<sup>ab</sup> </td><td style="vertical-align:top">4x8x4<br  />
 4x1x4<sup>b</sup><br  />
 4x1x8<sup>ab</sup> </td><td style="vertical-align:top"></td></tr>
<tr>
<td style="white-space: nowrap;">XDNA 2 </td><td style="vertical-align:top">4x16x16 </td><td style="vertical-align:top">4x8x8<br  />
 8x8x8 </td><td style="vertical-align:top">4x4x8<br  />
 8x4x8<br  />
 4x8x8<br  />
 2x8x8<sup>b</sup> </td><td style="vertical-align:top">8x2x8<sup>b</sup><br  />
 4x4x8<sup>b</sup> </td><td style="vertical-align:top">4x2x8<br  />
 8x2x8<br  />
 2x4x8<br  />
 4x4x8<br  />
 8x1x8<sup>b</sup> </td><td style="vertical-align:top">4x2x8<br  />
 2x4x8<sup>ab</sup><br  />
 4x4x8<sup>ab</sup><br  />
 4x1x8<sup>b</sup> </td><td style="vertical-align:top">4x4x8<sup>ab</sup> </td><td style="vertical-align:top">4x2x8<sup>ab</sup><br  />
 4x4x4<sup>ab</sup><br  />
 4x4x8<sup>ab</sup><br  />
 8x2x8<sup>ab</sup><br  />
 4x1x8<sup>b</sup> </td><td style="vertical-align:top">8x8x4<sup>ab</sup><br  />
 4x8x8<sup>abc</sup><br  />
 4x8x4<sup>ab</sup><br  />
 8x8x8<sup>e</sup><br  />
 8x1x8<sup>b</sup> </td><td style="vertical-align:top">4x8x4<sup>ab</sup> </td><td style="vertical-align:top">8x8x8<br  />
 8x8x16<sup>ab</sup> </td></tr>
</table>
<table class="doxtable">
<caption>Matrix multiplication modes for complex types (c16b/c32b/cfloat represent complex types)</caption>
<tr>
<th>Arch.</th><th>16b x c16b</th><th>16b x c32b</th><th>c16b x 16b</th><th>c16b x c16b</th><th>c16b x 32b </th><th>c16b x c32b</th><th>32b x c16b</th><th>32b x c32b<sup>c</sup></th><th>c32b x 16b</th><th>c32b x c16b </th><th>c32b x 32b<sup>c</sup></th><th>c32b x c32b<sup>c</sup> </th><th>bfloat16 x cbfloat16</th><th>cbfloat16 x bfloat16</th><th>cbfloat16 x cbfloat16 </th><th>float x cfloat<sup>d</sup></th><th>cfloat x float<sup>d</sup></th><th>cfloat x cfloat<sup>d</sup> </th></tr>
<tr>
<td style="white-space: nowrap;">AIE </td><td style="vertical-align:top">4x2x2<br  />
 4x4x4<sup>a</sup><br  />
 4x4x1 </td><td style="vertical-align:top">2x4x2<sup>a</sup><br  />
 2x4x4<sup>a</sup><br  />
 2x8x2<sup>a</sup><br  />
 4x4x2<sup>a</sup><br  />
 4x4x1<sup>a</sup> </td><td style="vertical-align:top">2x2x4<br  />
 2x2x8<sup>a</sup><br  />
 2x4x4<sup>a</sup><br  />
 2x4x8<sup>a</sup><br  />
 4x2x4<sup>a</sup><br  />
 4x4x2<sup>a</sup><br  />
 4x4x4<sup>a</sup> </td><td style="vertical-align:top">2x2x2<br  />
 2x4x2<sup>a</sup><br  />
 2x8x2<sup>a</sup><br  />
 2x4x4<sup>a</sup><br  />
 4x2x2<sup>a</sup><br  />
 4x4x2<sup>a</sup><br  />
 4x2x4<sup>a</sup><br  />
 4x4x1<sup>a</sup> </td><td style="vertical-align:top">2x2x2<br  />
 2x4x2<sup>a</sup><br  />
 2x8x2<sup>a</sup><br  />
 2x4x4<sup>a</sup><br  />
 4x2x2<sup>a</sup><br  />
 4x4x2<sup>a</sup><br  />
 4x2x4<sup>a</sup><br  />
 4x4x1<sup>a</sup> </td><td style="vertical-align:top">2x2x2<sup>a</sup><br  />
 2x4x2<sup>a</sup><br  />
 4x2x1<sup>a</sup> </td><td style="vertical-align:top">2x2x2<br  />
 2x4x2<sup>a</sup><br  />
 2x8x2<sup>a</sup><br  />
 2x4x4<sup>a</sup><br  />
 4x2x2<sup>a</sup><br  />
 4x4x2<sup>a</sup><br  />
 4x2x4<sup>a</sup><br  />
 4x4x1<sup>a</sup> </td><td style="vertical-align:top">2x2x2<sup>a</sup><br  />
 2x4x2<sup>a</sup><br  />
 4x2x1<sup>a</sup> </td><td style="vertical-align:top">2x4x2<sup>a</sup><br  />
 2x8x2<sup>a</sup><br  />
 2x4x4<sup>a</sup><br  />
 4x4x2<sup>a</sup> </td><td style="vertical-align:top">2x2x2<sup>a</sup><br  />
 2x4x2<sup>a</sup><br  />
 4x4x1<sup>a</sup> </td><td style="vertical-align:top">1x2x2<br  />
 2x2x2<sup>a</sup><br  />
 2x4x2<sup>a</sup><br  />
 4x4x1<sup>a</sup> </td><td style="vertical-align:top">1x2x2<sup>a</sup><br  />
 2x2x1<sup>a</sup><br  />
 2x2x1 </td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top">2x2x2<sup>a</sup><br  />
 2x4x2<sup>a</sup><br  />
 4x2x1<sup>a</sup> </td><td style="vertical-align:top">2x2x2<sup>a</sup><br  />
 2x4x2<sup>a</sup><br  />
 4x4x1<sup>a</sup><br  />
 2x4x1<sup>ab</sup> </td><td style="vertical-align:top">2x2x2<sup>a</sup><br  />
 2x2x4<sup>a</sup><br  />
 2x4x2<sup>a</sup><br  />
 4x2x2<sup>a</sup><br  />
 4x2x1<sup>a</sup> </td></tr>
<tr>
<td style="white-space: nowrap;">AIE-ML/XDNA 1 </td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top">2x4x8<sup>ab</sup><br  />
 4x4x4<sup>ab</sup> </td><td style="vertical-align:top">1x4x8<sup>ab</sup><br  />
 2x4x8<sup>ab</sup> </td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top">1x2x4<sup>ab</sup><br  />
 1x2x8<sup>ab</sup><br  />
 2x2x8<sup>ab</sup><br  />
 1x4x8<sup>ab</sup><br  />
 2x4x8<sup>ab</sup> </td><td style="vertical-align:top"></td><td style="vertical-align:top">1x2x8<sup>ab</sup> </td><td style="vertical-align:top">2x8x2<sup>ab</sup> </td><td style="vertical-align:top">2x8x2<sup>ab</sup> </td><td style="vertical-align:top">2x8x2<sup>ab</sup> </td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top"></td></tr>
<tr>
<td style="white-space: nowrap;">XDNA 2 </td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top">4x4x8<sup>ab</sup><br  />
 2x4x8<sup>ab</sup> </td><td style="vertical-align:top">1x4x8<sup>ab</sup><br  />
 2x2x16<sup>ab</sup> </td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top">1x2x4<sup>ab</sup><br  />
 1x2x8<sup>ab</sup><br  />
 1x2x16<sup>ab</sup> </td><td style="vertical-align:top"></td><td style="vertical-align:top">1x2x8<sup>ab</sup> </td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top"></td><td style="vertical-align:top"></td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><sup>a</sup> - Emulated using multiple intrinsic calls.<br  />
 <sup>b</sup> - Require additional data manipulation.<br  />
 <sup>c</sup> - 32b * 16b multiplications are emulated on AIE-ML/XDNA 1 and XDNA 2.<br  />
 <sup>d</sup> - float multiplications are emulated on AIE-ML/XDNA 1 and XDNA 2 using native bfloat16 multiplications.<br  />
 <sup>e</sup> - Mode available through block-floating-point emulation to increase throughput at the cost of accuracy. Enabled by defining AIE_API_EMULATE_BFLOAT16_MMUL_WITH_BFP16 at compile time.</dd></dl>
<h4><a class="anchor" id="group_mmul_page_multidim_gemm"></a>
GEMM leveraging multidimensional addressing</h4>
<dl class="section note"><dt>Note</dt><dd>Multi-dimensional addressing and the corresponding tensor buffer streams were introduced with AIE-ML/XDNA 1</dd></dl>
<p>Below is an example of an optimized <a class="el" href="types_8hpp.html#structbfloat16">bfloat16</a> GEMM kernel in which both input matrices, A and B, are addressed in the following 4D patterns (see <a class="el" href="group__group__memory.html#tensor_buffer_streams">Tensor Buffer Streams</a>):</p>
<div class="image">
<img src="mmul.png" alt="" width="50%"/>
</div>
<p>It is assumed that the data for both input matrices are pre-tiled and that the tiles are laid out in column-major order in memory.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> gemm_bf16xbf16(<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a> * matA, <a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a> * matB, <a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a> *__restrict matC,</div>
<div class="line">                    <span class="keywordtype">int</span> rowsA, <span class="keywordtype">int</span> inner, <span class="keywordtype">int</span> colsB)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>MMUL = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::mmul&lt;4, 8, 4, bfloat16, bfloat16, accauto&gt;</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> a_desc =  <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::make_tensor_descriptor&lt;bfloat16, 32&gt;</a>(</div>
<div class="line">                                               <a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(rowsA / 4 / 4, 4),</div>
<div class="line">                                               <a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(colsB / 4 / 4, 0),</div>
<div class="line">                                               <a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(inner / 8, rowsA / 4),</div>
<div class="line">                                               <a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(4u, 1));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> b_desc = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::make_tensor_descriptor&lt;bfloat16, 32&gt;</a>(</div>
<div class="line">                                               <a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(colsB / 4 / 4, 0),</div>
<div class="line">                                               <a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(colsB / 4 / 4, inner / 8 * 4),</div>
<div class="line">                                               <a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(inner / 8, 1),</div>
<div class="line">                                               <a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(4u, inner / 8));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> c_desc = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::make_tensor_descriptor&lt;bfloat16, 16&gt;</a>(</div>
<div class="line">                                               <a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(rowsA / 4 / 4, 4),</div>
<div class="line">                                               <a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(colsB / 4, rowsA / 4),</div>
<div class="line">                                               <a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(4u, 1));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> tsA = <a class="code hl_function" href="namespaceaie.html#a9812210816fa290cbc2ba16f8dfa058c">aie::make_tensor_buffer_stream</a>(matA, a_desc);</div>
<div class="line">    <span class="keyword">auto</span> tsB = <a class="code hl_function" href="namespaceaie.html#a9812210816fa290cbc2ba16f8dfa058c">aie::make_tensor_buffer_stream</a>(matB, b_desc);</div>
<div class="line">    <span class="keyword">auto</span> tsC = <a class="code hl_function" href="namespaceaie.html#a923b78df34a7daf38171b425a761f397">aie::make_restrict_tensor_buffer_stream</a>(matC, c_desc);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; rowsA * colsB / (16 * 16); ++j)</div>
<div class="line">    {</div>
<div class="line">        MMUL C00, C01, C02, C03;</div>
<div class="line">        MMUL C10, C11, C12, C13;</div>
<div class="line">        MMUL C20, C21, C22, C23;</div>
<div class="line">        MMUL C30, C31, C32, C33;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; inner / 8; ++i)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// The following pop calls are required to access the inner leaf stream.</span></div>
<div class="line">            <span class="comment">// As tsA and tsB are 4D streams, the returned inner stream will be 1D.</span></div>
<div class="line">            <span class="comment">//</span></div>
<div class="line">            <span class="comment">// Note that these calls advance the outer stream</span></div>
<div class="line">            <span class="keyword">auto</span> tsA_inner = tsA.pop();</div>
<div class="line">            <span class="keyword">auto</span> tsB_inner = tsB.pop();</div>
<div class="line"> </div>
<div class="line">            <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::vector&lt;bfloat16,32&gt;</a> Xbuff0, Xbuff1, Xbuff2, Xbuff3;</div>
<div class="line">            tsA_inner &gt;&gt; Xbuff0 &gt;&gt; Xbuff1 &gt;&gt; Xbuff2 &gt;&gt; Xbuff3;</div>
<div class="line"> </div>
<div class="line">            <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::vector&lt;bfloat16,32&gt;</a> Ybuff0, Ybuff1;</div>
<div class="line">            tsB_inner &gt;&gt; Ybuff0 &gt;&gt; Ybuff1;</div>
<div class="line"> </div>
<div class="line">            C00.mac(Xbuff0, Ybuff0); C01.mac(Xbuff0, Ybuff1);</div>
<div class="line">            C10.mac(Xbuff1, Ybuff0); C11.mac(Xbuff1, Ybuff1);</div>
<div class="line">            C20.mac(Xbuff2, Ybuff0); C21.mac(Xbuff2, Ybuff1);</div>
<div class="line">            C30.mac(Xbuff3, Ybuff0); C31.mac(Xbuff3, Ybuff1);</div>
<div class="line"> </div>
<div class="line">            tsB_inner &gt;&gt; Ybuff0 &gt;&gt; Ybuff1;</div>
<div class="line"> </div>
<div class="line">            C02.mac(Xbuff0, Ybuff0); C03.mac(Xbuff0, Ybuff1);</div>
<div class="line">            C12.mac(Xbuff1, Ybuff0); C13.mac(Xbuff1, Ybuff1);</div>
<div class="line">            C22.mac(Xbuff2, Ybuff0); C23.mac(Xbuff2, Ybuff1);</div>
<div class="line">            C32.mac(Xbuff3, Ybuff0); C33.mac(Xbuff3, Ybuff1);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        tsC &lt;&lt; C00.to_vector&lt;<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a>&gt;() &lt;&lt; C10.to_vector&lt;<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a>&gt;() &lt;&lt; C20.to_vector&lt;<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a>&gt;() &lt;&lt; C30.to_vector&lt;<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a>&gt;()</div>
<div class="line">            &lt;&lt; C01.to_vector&lt;<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a>&gt;() &lt;&lt; C11.to_vector&lt;<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a>&gt;() &lt;&lt; C21.to_vector&lt;<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a>&gt;() &lt;&lt; C31.to_vector&lt;<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a>&gt;()</div>
<div class="line">            &lt;&lt; C02.to_vector&lt;<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a>&gt;() &lt;&lt; C12.to_vector&lt;<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a>&gt;() &lt;&lt; C22.to_vector&lt;<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a>&gt;() &lt;&lt; C32.to_vector&lt;<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a>&gt;()</div>
<div class="line">            &lt;&lt; C03.to_vector&lt;<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a>&gt;() &lt;&lt; C13.to_vector&lt;<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a>&gt;() &lt;&lt; C23.to_vector&lt;<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a>&gt;() &lt;&lt; C33.to_vector&lt;<a class="code hl_struct" href="types_8hpp.html#structbfloat16">bfloat16</a>&gt;();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceaie_html_a923b78df34a7daf38171b425a761f397"><div class="ttname"><a href="namespaceaie.html#a923b78df34a7daf38171b425a761f397">aie::make_restrict_tensor_buffer_stream</a></div><div class="ttdeci">constexpr auto make_restrict_tensor_buffer_stream(T *__restrict base, const TensorDescriptor &amp;tensor_desc)</div><div class="ttdef"><b>Definition</b> aie.hpp:6798</div></div>
<div class="ttc" id="anamespaceaie_html_a9812210816fa290cbc2ba16f8dfa058c"><div class="ttname"><a href="namespaceaie.html#a9812210816fa290cbc2ba16f8dfa058c">aie::make_tensor_buffer_stream</a></div><div class="ttdeci">constexpr auto make_tensor_buffer_stream(T *base, const TensorDescriptor &amp;tensor_desc)</div><div class="ttdef"><b>Definition</b> aie.hpp:6751</div></div>
<div class="ttc" id="astructaie_1_1tensor__dim_html"><div class="ttname"><a href="structaie_1_1tensor__dim.html">aie::tensor_dim</a></div><div class="ttdef"><b>Definition</b> aie.hpp:6558</div></div>
<div class="ttc" id="atypes_8hpp_html_structbfloat16"><div class="ttname"><a href="types_8hpp.html#structbfloat16">bfloat16</a></div><div class="ttdef"><b>Definition</b> types.hpp:86</div></div>
</div><!-- fragment --><h4><a class="anchor" id="group_mmul_page_supported_sparse_modes"></a>
Supported Sparse Matrix Multiplication Modes</h4>
<p>AIE-ML/XDNA 1 introduced hardware support for sparse matrix multiplication. For an M x K x N matrix multiplication with A being M x K, B being K x N, and C being M x N, a sparse B matrix may be stored in memory using a data layout which avoids storing zero values.</p>
<dl class="section note"><dt>Note</dt><dd>Sparse matrix multiplications require that the sparse data be stored in column major layout. An internal transpose of the partially decompressed data is required by the underlying intrinsics and is carried out automatically by the API.</dd></dl>
<table class="doxtable">
<caption>Matrix multiplication modes for real types (sparse B matrix)</caption>
<tr>
<th>Arch.</th><th>8b x 4b</th><th>8b x 8b</th><th>16b x 8b</th><th>16b x 16b</th><th>bfloat16 x bfloat16 </th></tr>
<tr>
<td style="white-space: nowrap;">AIE-ML/XDNA 1 </td><td style="vertical-align:top">4x32x8 </td><td style="vertical-align:top">4x16x8<br  />
 8x16x8<sup>a</sup><br  />
 4x16x16<sup>ab</sup> </td><td style="vertical-align:top">2x16x8<br  />
 4x16x8<sup>a</sup> </td><td style="vertical-align:top">2x8x8<br  />
 4x8x8<sup>a</sup><br  />
 2x8x16<sup>ab</sup> </td><td style="vertical-align:top">4x16x4<br  />
 4x16x8<sup>ab</sup> </td></tr>
<tr>
<td style="white-space: nowrap;">XDNA 2 </td><td style="vertical-align:top"></td><td style="vertical-align:top">4x16x8<br  />
 8x16x8 </td><td style="vertical-align:top">2x16x8<br  />
 4x16x8 </td><td style="vertical-align:top">2x8x8<br  />
 4x8x8 </td><td style="vertical-align:top"></td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><sup>a</sup> - Emulated using multiple intrinsic calls <br  />
 <sup>b</sup> - Require additional data manipulation</dd></dl>
<p>The following example shows an optimized <code>int8 * sparse int8</code> GEMM:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> gemm_int8xint8_sparse(<a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a> * matA, <a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a> * matB, <a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a> *__restrict matC,</div>
<div class="line">                           <span class="keywordtype">int</span> rowsA, <span class="keywordtype">int</span> inner, <span class="keywordtype">int</span> colsB)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>MMUL = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::mmul&lt;4, 16, 8, int8, int8, accauto&gt;</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> a_desc = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::make_tensor_descriptor&lt;int8, 64&gt;</a>(<a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(rowsA / 4 / 4, 2),</div>
<div class="line">                                                        <a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(colsB / 4 / 4, 0),</div>
<div class="line">                                                        <a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(inner / 8, rowsA / 8),</div>
<div class="line">                                                        <a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(2u, 1));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> c_desc = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::make_tensor_descriptor&lt;int8, 32&gt;</a>(<a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(rowsA / 4 / 4, 4),</div>
<div class="line">                                                        <a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(colsB / 8, rowsA / 4),</div>
<div class="line">                                                        <a class="code hl_struct" href="structaie_1_1tensor__dim.html">aie::tensor_dim</a>(4u, 1));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> tsA = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::make_tensor_buffer_stream&lt;aie_dm_resource::a&gt;</a>(matA, a_desc);</div>
<div class="line">    <span class="keyword">auto</span> tsC = <a class="code hl_function" href="namespaceaie.html#a923b78df34a7daf38171b425a761f397">aie::make_restrict_tensor_buffer_stream</a>(matC, c_desc);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; rowsA / 16; j++)</div>
<div class="line">        chess_loop_range(2,)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> tsB = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::sparse_vector_input_buffer_stream&lt;int8, 128, aie_dm_resource::a&gt;</a>(matB);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> b = 0; b &lt; colsB / 16; b++)</div>
<div class="line">            chess_prepare_for_pipelining</div>
<div class="line">            chess_loop_range(2,)</div>
<div class="line">        {</div>
<div class="line">            MMUL C00, C01;</div>
<div class="line">            MMUL C10, C11;</div>
<div class="line">            MMUL C20, C21;</div>
<div class="line">            MMUL C30, C31;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; inner / 16; i++)</div>
<div class="line">                chess_prepare_for_pipelining</div>
<div class="line">                chess_loop_range(4,)</div>
<div class="line">            {</div>
<div class="line">                <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::vector&lt;int8,64&gt;</a> Sbuff0, Sbuff1, Sbuff2, Sbuff3;</div>
<div class="line">                tsA.pop() &gt;&gt; Sbuff0 &gt;&gt; Sbuff1;</div>
<div class="line">                tsA.pop() &gt;&gt; Sbuff2 &gt;&gt; Sbuff3;</div>
<div class="line"> </div>
<div class="line">                <span class="keyword">auto</span> [Xbuff0, Xbuff1] = <a class="code hl_function" href="group__group__reshape.html#ga88a182aac4704b1ad640383356008524">aie::interleave_zip</a>(Sbuff0, Sbuff2, 8);</div>
<div class="line">                <span class="keyword">auto</span> [Xbuff2, Xbuff3] = <a class="code hl_function" href="group__group__reshape.html#ga88a182aac4704b1ad640383356008524">aie::interleave_zip</a>(Sbuff1, Sbuff3, 8);</div>
<div class="line"> </div>
<div class="line">                <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::sparse_vector&lt;int8,128&gt;</a> Ybuff0, Ybuff1;</div>
<div class="line">                tsB &gt;&gt; Ybuff0 &gt;&gt; Ybuff1;</div>
<div class="line"> </div>
<div class="line">                C00.mac(Xbuff0, Ybuff0); C01.mac(Xbuff0, Ybuff1);</div>
<div class="line">                C10.mac(Xbuff1, Ybuff0); C11.mac(Xbuff1, Ybuff1);</div>
<div class="line">                C20.mac(Xbuff2, Ybuff0); C21.mac(Xbuff2, Ybuff1);</div>
<div class="line">                C30.mac(Xbuff3, Ybuff0); C31.mac(Xbuff3, Ybuff1);</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            tsC &lt;&lt; C00.to_vector&lt;<a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a>&gt;() &lt;&lt; C10.to_vector&lt;<a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a>&gt;() &lt;&lt; C20.to_vector&lt;<a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a>&gt;() &lt;&lt; C30.to_vector&lt;<a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a>&gt;()</div>
<div class="line">                &lt;&lt; C01.to_vector&lt;<a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a>&gt;() &lt;&lt; C11.to_vector&lt;<a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a>&gt;() &lt;&lt; C21.to_vector&lt;<a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a>&gt;() &lt;&lt; C31.to_vector&lt;<a class="code hl_typedef" href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a>&gt;();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group__reshape_html_ga88a182aac4704b1ad640383356008524"><div class="ttname"><a href="group__group__reshape.html#ga88a182aac4704b1ad640383356008524">aie::interleave_zip</a></div><div class="ttdeci">auto interleave_zip(const Vec1 &amp;v, const Vec2 &amp;w, unsigned chunk_size) -&gt; std::pair&lt; aie_dm_resource_remove_t&lt; Vec1 &gt;, aie_dm_resource_remove_t&lt; Vec1 &gt; &gt;</div><div class="ttdoc">Picks elements alternatively from the input vectors and writes them sequentially into the output vect...</div><div class="ttdef"><b>Definition</b> aie.hpp:2946</div></div>
<div class="ttc" id="atypes_8hpp_html_a3626f2f93183532b6e8b19234cc5c4d3"><div class="ttname"><a href="types_8hpp.html#a3626f2f93183532b6e8b19234cc5c4d3">int8</a></div><div class="ttdeci">int8_t int8</div><div class="ttdef"><b>Definition</b> types.hpp:20</div></div>
</div><!-- fragment --> </div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structaie_1_1mmul" id="structaie_1_1mmul"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structaie_1_1mmul">&#9670;&#160;</a></span>aie::mmul</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct aie::mmul</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><div class="compoundTemplParams">template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt;<br />
struct aie::mmul&lt; M_Elems, K_Elems, N_Elems, TypeA, TypeB, AccumTag &gt;</div><p>Type that encapsulates a blocked matrix multiplication C = A x B. </p>
<p>Objects of this type encapsulate the current result of the multiplication. The first result is computed with the mul method. New multiplications can be accumulated using the mac method.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M_Elems</td><td>Rows in matrix A. </td></tr>
    <tr><td class="paramname">K_Elems</td><td>Columns in matrix A / Rows in matrix B. </td></tr>
    <tr><td class="paramname">N_Elems</td><td>Columns in matrix B. </td></tr>
    <tr><td class="paramname">TypeA</td><td>Type of the elements in matrix A. It must meet <a class="el" href="conceptaie_1_1ElemBaseType.html">aie::ElemBaseType</a>. </td></tr>
    <tr><td class="paramname">TypeB</td><td>Optional. Type of the elements in matrix B. By default is the same as TypeA. It must meet <a class="el" href="conceptaie_1_1ElemBaseType.html">aie::ElemBaseType</a>. </td></tr>
    <tr><td class="paramname">AccumTag</td><td>Optional. Type of the elements of the accumulator that contains the results to be written in matrix C. It must meet <a class="el" href="conceptaie_1_1AccumElemBaseType.html">aie::AccumElemBaseType</a>. If not specified, it uses the <a class="el" href="group__group__arithmetic.html#DefaultAccumTag">default accumulation type</a> for multiplications of TypeA x TypeB. </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:aecf724607a1115c9b480a10d6a9db165" id="r_aecf724607a1115c9b480a10d6a9db165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#aecf724607a1115c9b480a10d6a9db165">accum_type</a> = <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> mmul_impl::accum_type</td></tr>
<tr class="separator:aecf724607a1115c9b480a10d6a9db165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af270180b73ac29c5f4668978f92770fb" id="r_af270180b73ac29c5f4668978f92770fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">using</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#af270180b73ac29c5f4668978f92770fb">mmul_impl</a> = detail::mmul&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, detail::to_native_accum_bits_for_mul_types_tag&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;()&gt;</td></tr>
<tr class="separator:af270180b73ac29c5f4668978f92770fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a784b84fb059e4393d67f414592d4c8a7" id="r_a784b84fb059e4393d67f414592d4c8a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#a784b84fb059e4393d67f414592d4c8a7">mmul</a> ()</td></tr>
<tr class="memdesc:a784b84fb059e4393d67f414592d4c8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a784b84fb059e4393d67f414592d4c8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d40819f4e59edcb15acf1e691da35dc" id="r_a5d40819f4e59edcb15acf1e691da35dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#a5d40819f4e59edcb15acf1e691da35dc">mmul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="group__group__mmul.html#aecf724607a1115c9b480a10d6a9db165">accum_type</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>)</td></tr>
<tr class="memdesc:a5d40819f4e59edcb15acf1e691da35dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a5d40819f4e59edcb15acf1e691da35dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f084eedb0072728d786ba5641bafea" id="r_a83f084eedb0072728d786ba5641bafea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#a83f084eedb0072728d786ba5641bafea">mmul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#structaie_1_1binary__op">binary_op</a>&lt; <a class="el" href="group__group__mmul.html#aecf724607a1115c9b480a10d6a9db165">accum_type</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">bool</a>, <a class="el" href="namespaceaie.html#a973928295d182c259e00eca230df0a01ad7ed4ee1df437474d005188535f74875">Operation::Zero</a> &gt; &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op</a>)</td></tr>
<tr class="memdesc:a83f084eedb0072728d786ba5641bafea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a83f084eedb0072728d786ba5641bafea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3783340807952e39c879bea6971254" id="r_a6d3783340807952e39c879bea6971254"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#a6d3783340807952e39c879bea6971254">mmul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#structaie_1_1unary__op">unary_op</a>&lt; <a class="el" href="group__group__mmul.html#aecf724607a1115c9b480a10d6a9db165">accum_type</a>, <a class="el" href="namespaceaie.html#a973928295d182c259e00eca230df0a01a319355b02926e62ce2ca7eaff819877a">Operation::Acc_Add</a> &gt; &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op</a>)</td></tr>
<tr class="memdesc:a6d3783340807952e39c879bea6971254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a6d3783340807952e39c879bea6971254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad397435c9d4bf9e73a46fe8db4ea98" id="r_a2ad397435c9d4bf9e73a46fe8db4ea98"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">T</a> &gt; </td></tr>
<tr class="memitem:a2ad397435c9d4bf9e73a46fe8db4ea98"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#a2ad397435c9d4bf9e73a46fe8db4ea98">mmul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">T</a>, <a class="el" href="group__group__mmul.html#ae480f2ba205f6be30e3174b11aba8ddf">size_C</a> &gt; &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">int</a> shift=0)</td></tr>
<tr class="memdesc:a2ad397435c9d4bf9e73a46fe8db4ea98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a2ad397435c9d4bf9e73a46fe8db4ea98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0937b228d05e5f0fb4790349340293" id="r_a2b0937b228d05e5f0fb4790349340293"><td class="memTemplParams" colspan="2">template&lt;VectorOrOp VecA, VectorOrOp VecB&gt; <br />
requires (VecA::size() == <a class="el" href="group__group__mmul.html#a62853fcc93664203ee36eeeb0879ad70">size_A</a> &amp;&amp; VecB::size() == <a class="el" href="group__group__mmul.html#acdf9dc9e6f580ad2296738a0f48a271b">size_B</a> &amp;&amp; std::is_same_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> VecA::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>&gt; &amp;&amp; std::is_same_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> VecB::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>&gt;)</td></tr>
<tr class="memitem:a2b0937b228d05e5f0fb4790349340293"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#a2b0937b228d05e5f0fb4790349340293">mac</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">VecA</a> &amp;a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">VecB</a> &amp;b)</td></tr>
<tr class="memdesc:a2b0937b228d05e5f0fb4790349340293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply the two given matrices and add it to the result.  <br /></td></tr>
<tr class="separator:a2b0937b228d05e5f0fb4790349340293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e28ef63d8045677d6600fb25f93c0d" id="r_ab0e28ef63d8045677d6600fb25f93c0d"><td class="memTemplParams" colspan="2">template&lt;VectorOrOp VecA, SparseVectorOrOp VecB&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>) &amp;&amp; VecA::size() == <a class="el" href="group__group__mmul.html#a62853fcc93664203ee36eeeb0879ad70">size_A</a> &amp;&amp; VecB::size() == <a class="el" href="group__group__mmul.html#acdf9dc9e6f580ad2296738a0f48a271b">size_B</a> &amp;&amp; std::is_same_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> VecA::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>&gt; &amp;&amp; std::is_same_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> VecB::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>&gt;)</td></tr>
<tr class="memitem:ab0e28ef63d8045677d6600fb25f93c0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#ab0e28ef63d8045677d6600fb25f93c0d">mac</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">VecA</a> &amp;a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">VecB</a> &amp;b)</td></tr>
<tr class="memdesc:ab0e28ef63d8045677d6600fb25f93c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply the two given matrices and add it to the result.  <br /></td></tr>
<tr class="separator:ab0e28ef63d8045677d6600fb25f93c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db1696d476ceb736f27113d5e323b41" id="r_a5db1696d476ceb736f27113d5e323b41"><td class="memTemplParams" colspan="2">template&lt;VectorOrOp VecA, VectorOrOp VecB&gt; <br />
requires (VecA::size() == <a class="el" href="group__group__mmul.html#a62853fcc93664203ee36eeeb0879ad70">size_A</a> &amp;&amp; VecB::size() == <a class="el" href="group__group__mmul.html#acdf9dc9e6f580ad2296738a0f48a271b">size_B</a> &amp;&amp; std::is_same_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> VecA::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>&gt; &amp;&amp; std::is_same_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> VecB::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>&gt;)</td></tr>
<tr class="memitem:a5db1696d476ceb736f27113d5e323b41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#a5db1696d476ceb736f27113d5e323b41">mul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">VecA</a> &amp;a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">VecB</a> &amp;b)</td></tr>
<tr class="memdesc:a5db1696d476ceb736f27113d5e323b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the result value with the multiplication of the two given matrices.  <br /></td></tr>
<tr class="separator:a5db1696d476ceb736f27113d5e323b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7427516f13e17b09d4b476f5582e936" id="r_af7427516f13e17b09d4b476f5582e936"><td class="memTemplParams" colspan="2">template&lt;VectorOrOp VecA, SparseVectorOrOp VecB&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>) &amp;&amp; VecA::size() == <a class="el" href="group__group__mmul.html#a62853fcc93664203ee36eeeb0879ad70">size_A</a> &amp;&amp; VecB::size() == <a class="el" href="group__group__mmul.html#acdf9dc9e6f580ad2296738a0f48a271b">size_B</a> &amp;&amp; std::is_same_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> VecA::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>&gt; &amp;&amp; std::is_same_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> VecB::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>&gt;)</td></tr>
<tr class="memitem:af7427516f13e17b09d4b476f5582e936"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#af7427516f13e17b09d4b476f5582e936">mul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">VecA</a> &amp;a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">VecB</a> &amp;b)</td></tr>
<tr class="memdesc:af7427516f13e17b09d4b476f5582e936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the result value with the multiplication of the two given matrices.  <br /></td></tr>
<tr class="separator:af7427516f13e17b09d4b476f5582e936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0512e04bd51e3726f2fd5eb9e0845aa" id="r_ae0512e04bd51e3726f2fd5eb9e0845aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#ae0512e04bd51e3726f2fd5eb9e0845aa">operator accum_type</a> () <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a></td></tr>
<tr class="memdesc:ae0512e04bd51e3726f2fd5eb9e0845aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator to accumulator.  <br /></td></tr>
<tr class="separator:ae0512e04bd51e3726f2fd5eb9e0845aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3fafbc95fec0e2709c652fa1b62f3d" id="r_a0f3fafbc95fec0e2709c652fa1b62f3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__mmul.html#structaie_1_1mmul">mmul</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#a0f3fafbc95fec0e2709c652fa1b62f3d">operator=</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="group__group__mmul.html#aecf724607a1115c9b480a10d6a9db165">accum_type</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>)</td></tr>
<tr class="memdesc:a0f3fafbc95fec0e2709c652fa1b62f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitialize the mmul object using the given accumulator.  <br /></td></tr>
<tr class="separator:a0f3fafbc95fec0e2709c652fa1b62f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9873dbf10089ac12451a7bbcb09d9918" id="r_a9873dbf10089ac12451a7bbcb09d9918"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__mmul.html#aecf724607a1115c9b480a10d6a9db165">accum_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#a9873dbf10089ac12451a7bbcb09d9918">to_accum</a> () <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a></td></tr>
<tr class="memdesc:a9873dbf10089ac12451a7bbcb09d9918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of the multiplication as an accumulator.  <br /></td></tr>
<tr class="separator:a9873dbf10089ac12451a7bbcb09d9918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20aaa6aac29e5a017f03116328d5103b" id="r_a20aaa6aac29e5a017f03116328d5103b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">T</a> &gt; </td></tr>
<tr class="memitem:a20aaa6aac29e5a017f03116328d5103b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">T</a>, <a class="el" href="group__group__mmul.html#ae480f2ba205f6be30e3174b11aba8ddf">size_C</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#a20aaa6aac29e5a017f03116328d5103b">to_vector</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">int</a> shift=0) <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a></td></tr>
<tr class="memdesc:a20aaa6aac29e5a017f03116328d5103b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of the multiplication as a vector of the requested type.  <br /></td></tr>
<tr class="separator:a20aaa6aac29e5a017f03116328d5103b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Member Functions</h3></td></tr>
<tr class="memitem:a012e5142c8da7eaf73eec78601460583" id="r_a012e5142c8da7eaf73eec78601460583"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">static</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#a012e5142c8da7eaf73eec78601460583">size</a> ()</td></tr>
<tr class="memdesc:a012e5142c8da7eaf73eec78601460583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of elements in matrix C.  <br /></td></tr>
<tr class="separator:a012e5142c8da7eaf73eec78601460583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Attributes</h3></td></tr>
<tr class="memitem:aa4ceb6cc4bce8a28b3b562b6ab9a5157" id="r_aa4ceb6cc4bce8a28b3b562b6ab9a5157"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">static</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#aa4ceb6cc4bce8a28b3b562b6ab9a5157">K</a> = <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a></td></tr>
<tr class="memdesc:aa4ceb6cc4bce8a28b3b562b6ab9a5157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of columns in matrix A, and number of rows in matrix B.  <br /></td></tr>
<tr class="separator:aa4ceb6cc4bce8a28b3b562b6ab9a5157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44cdb433778e031ade9377c66a0dd60" id="r_af44cdb433778e031ade9377c66a0dd60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">static</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#af44cdb433778e031ade9377c66a0dd60">M</a> = <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a></td></tr>
<tr class="memdesc:af44cdb433778e031ade9377c66a0dd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows in matrix A.  <br /></td></tr>
<tr class="separator:af44cdb433778e031ade9377c66a0dd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06bfb15c8e54ca85dfefb0597e976ed" id="r_ac06bfb15c8e54ca85dfefb0597e976ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">static</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#ac06bfb15c8e54ca85dfefb0597e976ed">N</a> = <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a></td></tr>
<tr class="memdesc:ac06bfb15c8e54ca85dfefb0597e976ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of columns in matrix B.  <br /></td></tr>
<tr class="separator:ac06bfb15c8e54ca85dfefb0597e976ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62853fcc93664203ee36eeeb0879ad70" id="r_a62853fcc93664203ee36eeeb0879ad70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">static</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#a62853fcc93664203ee36eeeb0879ad70">size_A</a> = <a class="el" href="group__group__mmul.html#af44cdb433778e031ade9377c66a0dd60">M</a> * <a class="el" href="group__group__mmul.html#aa4ceb6cc4bce8a28b3b562b6ab9a5157">K</a></td></tr>
<tr class="memdesc:a62853fcc93664203ee36eeeb0879ad70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements in matrix A.  <br /></td></tr>
<tr class="separator:a62853fcc93664203ee36eeeb0879ad70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf9dc9e6f580ad2296738a0f48a271b" id="r_acdf9dc9e6f580ad2296738a0f48a271b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">static</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#acdf9dc9e6f580ad2296738a0f48a271b">size_B</a> = <a class="el" href="group__group__mmul.html#aa4ceb6cc4bce8a28b3b562b6ab9a5157">K</a> * <a class="el" href="group__group__mmul.html#ac06bfb15c8e54ca85dfefb0597e976ed">N</a></td></tr>
<tr class="memdesc:acdf9dc9e6f580ad2296738a0f48a271b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements in matrix B.  <br /></td></tr>
<tr class="separator:acdf9dc9e6f580ad2296738a0f48a271b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae480f2ba205f6be30e3174b11aba8ddf" id="r_ae480f2ba205f6be30e3174b11aba8ddf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">static</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mmul.html#ae480f2ba205f6be30e3174b11aba8ddf">size_C</a> = <a class="el" href="group__group__mmul.html#af44cdb433778e031ade9377c66a0dd60">M</a> * <a class="el" href="group__group__mmul.html#ac06bfb15c8e54ca85dfefb0597e976ed">N</a></td></tr>
<tr class="memdesc:ae480f2ba205f6be30e3174b11aba8ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements in matrix C.  <br /></td></tr>
<tr class="separator:ae480f2ba205f6be30e3174b11aba8ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a id="aecf724607a1115c9b480a10d6a9db165" name="aecf724607a1115c9b480a10d6a9db165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf724607a1115c9b480a10d6a9db165">&#9670;&#160;</a></span>accum_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">using</a> <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::accum_type =  <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> mmul_impl::accum_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af270180b73ac29c5f4668978f92770fb" name="af270180b73ac29c5f4668978f92770fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af270180b73ac29c5f4668978f92770fb">&#9670;&#160;</a></span>mmul_impl</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">using</a> <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::mmul_impl =  detail::mmul&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, detail::to_native_accum_bits_for_mul_types_tag&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a>&gt;()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a784b84fb059e4393d67f414592d4c8a7" name="a784b84fb059e4393d67f414592d4c8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784b84fb059e4393d67f414592d4c8a7">&#9670;&#160;</a></span>mmul() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::mmul </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Data will qualify as zero initialised for the first operation.</p>
<dl class="section note"><dt>Note</dt><dd>The result may not be explicitly zero initialized before the first <a class="el" href="group__group__mmul.html#a5db1696d476ceb736f27113d5e323b41">mul</a> or <a class="el" href="group__group__mmul.html#a2b0937b228d05e5f0fb4790349340293">mac</a> operation takes place. </dd></dl>

</div>
</div>
<a id="a5d40819f4e59edcb15acf1e691da35dc" name="a5d40819f4e59edcb15acf1e691da35dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d40819f4e59edcb15acf1e691da35dc">&#9670;&#160;</a></span>mmul() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::mmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="group__group__mmul.html#aecf724607a1115c9b480a10d6a9db165">accum_type</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Data is initialized from the given accumulator in row-major order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accumulator data is initialized from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d3783340807952e39c879bea6971254" name="a6d3783340807952e39c879bea6971254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3783340807952e39c879bea6971254">&#9670;&#160;</a></span>mmul() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::mmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#structaie_1_1unary__op">unary_op</a>&lt; <a class="el" href="group__group__mmul.html#aecf724607a1115c9b480a10d6a9db165">accum_type</a>, <a class="el" href="namespaceaie.html#a973928295d182c259e00eca230df0a01a319355b02926e62ce2ca7eaff819877a">Operation::Acc_Add</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Data is initialized from the given operation modifier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td><a class="el" href="group__group__basic__types__ops.html#gaaf0434fe3deae5662eabddf0ec95dc26">aie::op_add</a> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__basic__types__ops.html#gaaf0434fe3deae5662eabddf0ec95dc26" title="Returns an addition operation modifier for the given accumulator.">aie::op_add</a> </dd></dl>

</div>
</div>
<a id="a83f084eedb0072728d786ba5641bafea" name="a83f084eedb0072728d786ba5641bafea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f084eedb0072728d786ba5641bafea">&#9670;&#160;</a></span>mmul() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::mmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#structaie_1_1binary__op">binary_op</a>&lt; <a class="el" href="group__group__mmul.html#aecf724607a1115c9b480a10d6a9db165">accum_type</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">bool</a>, <a class="el" href="namespaceaie.html#a973928295d182c259e00eca230df0a01ad7ed4ee1df437474d005188535f74875">Operation::Zero</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Data is initialized from the given operation modifier.</p>
<p>This modifier conditionally qualifies the data to be represented as if it were zero for the first operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td><a class="el" href="group__group__basic__types__ops.html#gadfa48d459f3b3cc3ffcb04bc48ef9424">aie::op_zero</a> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__group__basic__types__ops.html#gadfa48d459f3b3cc3ffcb04bc48ef9424" title="Zeroes out the given accumulator or not depending on the zero parameter.">aie::op_zero</a> </dd></dl>

</div>
</div>
<a id="a2ad397435c9d4bf9e73a46fe8db4ea98" name="a2ad397435c9d4bf9e73a46fe8db4ea98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad397435c9d4bf9e73a46fe8db4ea98">&#9670;&#160;</a></span>mmul() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::mmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">T</a>, <a class="el" href="group__group__mmul.html#ae480f2ba205f6be30e3174b11aba8ddf">size_C</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">int</a>&#160;</td>
          <td class="paramname"><em>shift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Data is initialized from the given vector.</p>
<p>Data is expected to be row-major layout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector data is initialized from. </td></tr>
    <tr><td class="paramname">shift</td><td>Upshift in bits to be applied to input data. This parameter is ignored for floating-point types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a2b0937b228d05e5f0fb4790349340293" name="a2b0937b228d05e5f0fb4790349340293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0937b228d05e5f0fb4790349340293">&#9670;&#160;</a></span>mac() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<div class="memtemplate">
template&lt;VectorOrOp VecA, VectorOrOp VecB&gt; <br />
requires (VecA::size() == <a class="el" href="group__group__mmul.html#a62853fcc93664203ee36eeeb0879ad70">size_A</a> &amp;&amp; VecB::size() == <a class="el" href="group__group__mmul.html#acdf9dc9e6f580ad2296738a0f48a271b">size_B</a> &amp;&amp; std::is_same_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> VecA::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>&gt; &amp;&amp; std::is_same_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> VecB::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">void</a> <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::mac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">VecA</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">VecB</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply the two given matrices and add it to the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Represents the A input matrix with row-major data layout. The number of elements must be <a class="el" href="group__group__mmul.html#a62853fcc93664203ee36eeeb0879ad70" title="Number of elements in matrix A.">mmul::size_A</a> (M * K). It must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
    <tr><td class="paramname">b</td><td>Represents the B input matrix with row-major data layout. The number of elements must be <a class="el" href="group__group__mmul.html#acdf9dc9e6f580ad2296738a0f48a271b" title="Number of elements in matrix B.">mmul::size_B</a> (K * N). It must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0e28ef63d8045677d6600fb25f93c0d" name="ab0e28ef63d8045677d6600fb25f93c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e28ef63d8045677d6600fb25f93c0d">&#9670;&#160;</a></span>mac() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<div class="memtemplate">
template&lt;VectorOrOp VecA, SparseVectorOrOp VecB&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>) &amp;&amp; VecA::size() == <a class="el" href="group__group__mmul.html#a62853fcc93664203ee36eeeb0879ad70">size_A</a> &amp;&amp; VecB::size() == <a class="el" href="group__group__mmul.html#acdf9dc9e6f580ad2296738a0f48a271b">size_B</a> &amp;&amp; std::is_same_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> VecA::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>&gt; &amp;&amp; std::is_same_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> VecB::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">void</a> <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::mac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">VecA</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">VecB</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiply the two given matrices and add it to the result. </p>
<p>Matrix B is sparse.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Vector that represents the A input matrix. The number of elements must be <a class="el" href="group__group__mmul.html#a62853fcc93664203ee36eeeb0879ad70" title="Number of elements in matrix A.">mmul::size_A</a> (M * K). It must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
    <tr><td class="paramname">b</td><td>Sparse vector that represents the B input matrix. The number of elements must be <a class="el" href="group__group__mmul.html#acdf9dc9e6f580ad2296738a0f48a271b" title="Number of elements in matrix B.">mmul::size_B</a> (K * N). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5db1696d476ceb736f27113d5e323b41" name="a5db1696d476ceb736f27113d5e323b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db1696d476ceb736f27113d5e323b41">&#9670;&#160;</a></span>mul() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<div class="memtemplate">
template&lt;VectorOrOp VecA, VectorOrOp VecB&gt; <br />
requires (VecA::size() == <a class="el" href="group__group__mmul.html#a62853fcc93664203ee36eeeb0879ad70">size_A</a> &amp;&amp; VecB::size() == <a class="el" href="group__group__mmul.html#acdf9dc9e6f580ad2296738a0f48a271b">size_B</a> &amp;&amp; std::is_same_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> VecA::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>&gt; &amp;&amp; std::is_same_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> VecB::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">void</a> <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">VecA</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">VecB</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the result value with the multiplication of the two given matrices. </p>
<p>Data is overwritten regardless how it was initialised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Represents the A input matrix with row-major data layout. The number of elements must be <a class="el" href="group__group__mmul.html#a62853fcc93664203ee36eeeb0879ad70" title="Number of elements in matrix A.">mmul::size_A</a> (M * K). It must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
    <tr><td class="paramname">b</td><td>Represents the B input matrix with row-major data layout. The number of elements must be <a class="el" href="group__group__mmul.html#acdf9dc9e6f580ad2296738a0f48a271b" title="Number of elements in matrix B.">mmul::size_B</a> (K * N). It must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7427516f13e17b09d4b476f5582e936" name="af7427516f13e17b09d4b476f5582e936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7427516f13e17b09d4b476f5582e936">&#9670;&#160;</a></span>mul() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<div class="memtemplate">
template&lt;VectorOrOp VecA, SparseVectorOrOp VecB&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>) &amp;&amp; VecA::size() == <a class="el" href="group__group__mmul.html#a62853fcc93664203ee36eeeb0879ad70">size_A</a> &amp;&amp; VecB::size() == <a class="el" href="group__group__mmul.html#acdf9dc9e6f580ad2296738a0f48a271b">size_B</a> &amp;&amp; std::is_same_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> VecA::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>&gt; &amp;&amp; std::is_same_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> VecB::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">void</a> <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">VecA</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">VecB</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the result value with the multiplication of the two given matrices. </p>
<p>Matrix B is sparse.</p>
<p>Data is overwritten regardless how it was initialised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Vector that represents the A input matrix. The number of elements must be <a class="el" href="group__group__mmul.html#a62853fcc93664203ee36eeeb0879ad70" title="Number of elements in matrix A.">mmul::size_A</a> (M * K). It must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
    <tr><td class="paramname">b</td><td>Sparse vector that represents the B input matrix. The number of elements must be <a class="el" href="group__group__mmul.html#acdf9dc9e6f580ad2296738a0f48a271b" title="Number of elements in matrix B.">mmul::size_B</a> (K * N). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0512e04bd51e3726f2fd5eb9e0845aa" name="ae0512e04bd51e3726f2fd5eb9e0845aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0512e04bd51e3726f2fd5eb9e0845aa">&#9670;&#160;</a></span>operator accum_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">::operator</a> <a class="el" href="group__group__mmul.html#aecf724607a1115c9b480a10d6a9db165">accum_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator to accumulator. </p>

</div>
</div>
<a id="a0f3fafbc95fec0e2709c652fa1b62f3d" name="a0f3fafbc95fec0e2709c652fa1b62f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3fafbc95fec0e2709c652fa1b62f3d">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__mmul.html#structaie_1_1mmul">mmul</a> &amp; <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">::operator</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="group__group__mmul.html#aecf724607a1115c9b480a10d6a9db165">accum_type</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reinitialize the mmul object using the given accumulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accumulator data is initialized from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a012e5142c8da7eaf73eec78601460583" name="a012e5142c8da7eaf73eec78601460583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012e5142c8da7eaf73eec78601460583">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">static</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of elements in matrix C. </p>

</div>
</div>
<a id="a9873dbf10089ac12451a7bbcb09d9918" name="a9873dbf10089ac12451a7bbcb09d9918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9873dbf10089ac12451a7bbcb09d9918">&#9670;&#160;</a></span>to_accum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__mmul.html#aecf724607a1115c9b480a10d6a9db165">accum_type</a> <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::to_accum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of the multiplication as an accumulator. </p>

</div>
</div>
<a id="a20aaa6aac29e5a017f03116328d5103b" name="a20aaa6aac29e5a017f03116328d5103b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20aaa6aac29e5a017f03116328d5103b">&#9670;&#160;</a></span>to_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">T</a>, <a class="el" href="group__group__mmul.html#ae480f2ba205f6be30e3174b11aba8ddf">size_C</a> &gt; <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::to_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">int</a>&#160;</td>
          <td class="paramname"><em>shift</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the result of the multiplication as a vector of the requested type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shift</td><td>Downshift in bits to be applied to output data. This parameter is ignored for floating-point types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="aa4ceb6cc4bce8a28b3b562b6ab9a5157" name="aa4ceb6cc4bce8a28b3b562b6ab9a5157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ceb6cc4bce8a28b3b562b6ab9a5157">&#9670;&#160;</a></span>K</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::K = <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of columns in matrix A, and number of rows in matrix B. </p>

</div>
</div>
<a id="af44cdb433778e031ade9377c66a0dd60" name="af44cdb433778e031ade9377c66a0dd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44cdb433778e031ade9377c66a0dd60">&#9670;&#160;</a></span>M</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::M = <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of rows in matrix A. </p>

</div>
</div>
<a id="ac06bfb15c8e54ca85dfefb0597e976ed" name="ac06bfb15c8e54ca85dfefb0597e976ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06bfb15c8e54ca85dfefb0597e976ed">&#9670;&#160;</a></span>N</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::N = <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of columns in matrix B. </p>

</div>
</div>
<a id="a62853fcc93664203ee36eeeb0879ad70" name="a62853fcc93664203ee36eeeb0879ad70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62853fcc93664203ee36eeeb0879ad70">&#9670;&#160;</a></span>size_A</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::size_A = <a class="el" href="group__group__mmul.html#af44cdb433778e031ade9377c66a0dd60">M</a> * <a class="el" href="group__group__mmul.html#aa4ceb6cc4bce8a28b3b562b6ab9a5157">K</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements in matrix A. </p>

</div>
</div>
<a id="acdf9dc9e6f580ad2296738a0f48a271b" name="acdf9dc9e6f580ad2296738a0f48a271b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf9dc9e6f580ad2296738a0f48a271b">&#9670;&#160;</a></span>size_B</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::size_B = <a class="el" href="group__group__mmul.html#aa4ceb6cc4bce8a28b3b562b6ab9a5157">K</a> * <a class="el" href="group__group__mmul.html#ac06bfb15c8e54ca85dfefb0597e976ed">N</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements in matrix B. </p>

</div>
</div>
<a id="ae480f2ba205f6be30e3174b11aba8ddf" name="ae480f2ba205f6be30e3174b11aba8ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae480f2ba205f6be30e3174b11aba8ddf">&#9670;&#160;</a></span>size_C</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> M_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> K_Elems, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> N_Elems, ElemBaseType TypeA, ElemBaseType TypeB = TypeA, AccumElemBaseType AccumTag = accauto&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> <a class="el" href="group__group__mmul.html#structaie_1_1mmul">aie::mmul</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">M_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">K_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">N_Elems</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeA</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TypeB</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a> &gt;::size_C = <a class="el" href="group__group__mmul.html#af44cdb433778e031ade9377c66a0dd60">M</a> * <a class="el" href="group__group__mmul.html#ac06bfb15c8e54ca85dfefb0597e976ed">N</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements in matrix C. </p>

</div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- SPDX-License-Identifier: MIT -->
<!-- Copyright (C) 2022 Xilinx, Inc. -->
<!-- Copyright (C) 2022-2024 Advanced Micro Devices, Inc. -->
<!-- HTML footer for doxygen 1.9.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">UG1529 &copy; 2024 Advanced Micro Devices, Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
