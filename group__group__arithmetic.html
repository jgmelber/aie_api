<!-- SPDX-License-Identifier: MIT -->
<!-- Copyright (C) 2022 Xilinx, Inc. -->
<!-- Copyright (C) 2022-2024 Advanced Micro Devices, Inc. -->
<!-- HTML header for doxygen 1.9.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AI Engine API User Guide: Arithmetic</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="tables.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow" style="height: 60px">
  <td id="projectlogo" style="vertical-align: middle; padding-left: 15px; padding-right: 30px"><img height="32" alt="Logo" src="amd-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">AI Engine API User Guide<span id="projectnumber">&#160;(AIE-API)           2025.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__group__arithmetic.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Arithmetic</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<p>AIE API provides a set of functions that implement arithmetic operations on vector types. </p>
<p>Operands may be vectors, values or vector element references and the supported operand combinations are:</p><ul>
<li>Vector / Vector: the type and the size of the vectors must match. The operation is performed element-wise between the corresponding elements in each vector.</li>
<li>Value / Vector: the type of the value and the type of the elements of the vector must match. The operation has the same result as if the value was broadcast to a vector and then operated with the vector argument.</li>
<li>Vector element reference / Vector. Similar as Value / Vector, but using an element reference, the AIE API may optimize the operation by accessing the element directly from its original location.</li>
</ul>
<p>The following code snippet shows an example that adds two input arrays into an output array using vectors. For simplicity count must be divisible by 8.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> add(<a class="code hl_typedef" href="types_8hpp.html#a3271a6f688eb2ba4047a2982ff49919a">int32</a> * __restrict out,</div>
<div class="line">         <span class="keyword">const</span> <a class="code hl_typedef" href="types_8hpp.html#a3271a6f688eb2ba4047a2982ff49919a">int32</a> * __restrict in1, <span class="keyword">const</span> <a class="code hl_typedef" href="types_8hpp.html#a3271a6f688eb2ba4047a2982ff49919a">int32</a> * __restrict in2, <span class="keywordtype">unsigned</span> count)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 8; i &lt; count; i += 8) {</div>
<div class="line">        <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::vector&lt;int32, 8&gt;</a> vec = <a class="code hl_function" href="group__group__arithmetic.html#ga9617379444e0c56c89d2e46bf3de66df">aie::add</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::load_v&lt;8&gt;</a>(in1 + i),</div>
<div class="line">                                             <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::load_v&lt;8&gt;</a>(in2 + i));</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_function" href="group__group__memory.html#gaa134a9db67641fc7ee69be78c7b00bf6">aie::store_v</a>(out, vec);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__group__arithmetic_html_ga9617379444e0c56c89d2e46bf3de66df"><div class="ttname"><a href="group__group__arithmetic.html#ga9617379444e0c56c89d2e46bf3de66df">aie::add</a></div><div class="ttdeci">auto add(const Vec1 &amp;v1, const Vec2 &amp;v2) -&gt; aie_dm_resource_remove_t&lt; Vec1 &gt;</div><div class="ttdoc">Returns a vector with the element-wise addition of the two input vectors.</div><div class="ttdef"><b>Definition</b> aie.hpp:3581</div></div>
<div class="ttc" id="agroup__group__memory_html_gaa134a9db67641fc7ee69be78c7b00bf6"><div class="ttname"><a href="group__group__memory.html#gaa134a9db67641fc7ee69be78c7b00bf6">aie::store_v</a></div><div class="ttdeci">T1 * store_v(T1 *ptr, const vector&lt; T2, Elems &gt; &amp;v)</div><div class="ttdoc">Store a vector of Elems size whose elements have type T.</div><div class="ttdef"><b>Definition</b> aie.hpp:740</div></div>
<div class="ttc" id="anamespaceaie_html_a43a139787b463ec1b70e6d1e25621808"><div class="ttname"><a href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::op_result_type_t</a></div><div class="ttdeci">typename op_result_helper&lt; T, Op &gt;::type op_result_type_t</div><div class="ttdef"><b>Definition</b> expr.hpp:349</div></div>
<div class="ttc" id="atypes_8hpp_html_a3271a6f688eb2ba4047a2982ff49919a"><div class="ttname"><a href="types_8hpp.html#a3271a6f688eb2ba4047a2982ff49919a">int32</a></div><div class="ttdeci">int32_t int32</div><div class="ttdef"><b>Definition</b> types.hpp:22</div></div>
</div><!-- fragment --><p>Operations that include a multiplication return an accumulator. The API defines a default accumulation, shown below, for each combination of types. Note that the input types are unorderded.</p>
<p><a class="anchor" id="DefaultAccumTag"></a></p><table class="doxtable">
<caption>Default accumulator tag for different integral factor types</caption>
<tr>
<th>Type1 </th><td>int4 </td><td>int8 </td><td>int8 </td><td>int16 </td><td>int16 </td><td>int32 </td><td>cint16 </td><td>cint16 </td><td>cint16 </td><td>cint16 </td><td>cint32 </td><td>cint32 </td><td>cint32 </td></tr>
<tr>
<th>Type2 </th><td>int8 </td><td>int8 </td><td>int16 </td><td>int16 </td><td>int32 </td><td>int32 </td><td>int16 </td><td>int32 </td><td>cint16 </td><td>cint32 </td><td>int16 </td><td>int32 </td><td>cint32 </td></tr>
<tr>
<th>AIE </th><td></td><td>acc48 </td><td>acc48 </td><td>acc48 </td><td>acc48 </td><td>acc80 </td><td>cacc48 </td><td>cacc48 </td><td>cacc48 </td><td>cacc48 </td><td>cacc48 </td><td>cacc80 </td><td>cacc80 </td></tr>
<tr>
<th>AIE-ML<br  />
XDNA 1 </th><td>acc32 </td><td>acc32 </td><td>acc32 </td><td>acc32 </td><td>acc64 </td><td>acc64<sup>a</sup> </td><td>cacc64 </td><td>cacc64 </td><td>cacc64 </td><td>cacc64 </td><td>cacc64 </td><td>cacc64 <sup>a</sup></td><td>cacc64<sup>a</sup> </td></tr>
<tr>
<th>XDNA 2 </th><td>acc32 </td><td>acc32 </td><td>acc32 </td><td>acc32 </td><td>acc64 </td><td>acc64<sup>a</sup> </td><td>cacc64 </td><td>cacc64 </td><td>cacc64 </td><td>cacc64 </td><td>cacc64 </td><td>cacc64 <sup>a</sup></td><td>cacc64<sup>a</sup> </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><sup>a</sup> - 32b x 32b multiplication is not natively supported on AIE-ML/XDNA 1 or XDNA 2 and is emulated using two 32b x 16b muls.<br  />
</dd></dl>
<table class="doxtable">
<caption>Default accumulator tag for different floating point factor types</caption>
<tr>
<th>Type1 </th><td>bfloat16 </td><td>bfloat16 </td><td>cbfloat16 </td><td>float </td><td>float </td><td>cfloat </td><td>bfp16ebs8 </td><td>bfp16ebs16 </td></tr>
<tr>
<th>Type2 </th><td>bfloat16 </td><td>cbfloat16 </td><td>cbfloat16 </td><td>float </td><td>cfloat </td><td>cfloat </td><td>bfp16ebs8 </td><td>bfp16ebs16 </td></tr>
<tr>
<th>AIE </th><td></td><td></td><td></td><td>accfloat </td><td>caccfloat </td><td>caccfloat </td><td></td><td></td></tr>
<tr>
<th>AIE-ML<br  />
XDNA 1 </th><td>accfloat </td><td>caccfloat </td><td>caccfloat </td><td>accfloat<sup>a</sup> </td><td>caccfloat<sup>a</sup> </td><td>caccfloat<sup>a</sup> </td><td></td><td></td></tr>
<tr>
<th>XDNA 2 </th><td>accfloat </td><td>caccfloat </td><td>caccfloat </td><td>accfloat<sup>a</sup> </td><td>caccfloat<sup>a</sup> </td><td>caccfloat<sup>a</sup> </td><td>accfloat </td><td>accfloat </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><sup>a</sup> - float multiplication is emulated on AIE-ML/XDNA 1 and XDNA 2 using native bfloat16 multiplications.<br  />
</dd></dl>
<p>Users may specify a larger number of accumulation bits by explicitly passing an accumulator tag:</p>
<div class="fragment"><div class="line"><span class="comment">// Default accumulation will be used</span></div>
<div class="line"><span class="keyword">auto</span> acc = <a class="code hl_function" href="group__group__arithmetic.html#gac7ff4236ae3cbc544f118df14881ee4e">aie::mul</a>(v1, v2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 64b accumulation, at least, will be used</span></div>
<div class="line"><span class="keyword">auto</span> acc = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie::mul&lt;acc64&gt;</a>(v1, v2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// For multiply-add operations, the API uses the same accumulation as the given accumulator (cannot be overriden)</span></div>
<div class="line"><span class="keyword">auto</span> acc2 = <a class="code hl_function" href="group__group__arithmetic.html#gaf56db067d71355ecab1b3fd9e406cd55">aie::mac</a>(acc, v1, v2);</div>
<div class="ttc" id="agroup__group__arithmetic_html_gac7ff4236ae3cbc544f118df14881ee4e"><div class="ttname"><a href="group__group__arithmetic.html#gac7ff4236ae3cbc544f118df14881ee4e">aie::mul</a></div><div class="ttdeci">constexpr auto mul(const Vec1 &amp;v1, const Vec2 &amp;v2) -&gt; accum&lt; AccumTag, Vec1::size()&gt;</div><div class="ttdoc">Returns an accumulator of the requested type with the element-wise multiplication of the two input ve...</div><div class="ttdef"><b>Definition</b> aie.hpp:4566</div></div>
<div class="ttc" id="agroup__group__arithmetic_html_gaf56db067d71355ecab1b3fd9e406cd55"><div class="ttname"><a href="group__group__arithmetic.html#gaf56db067d71355ecab1b3fd9e406cd55">aie::mac</a></div><div class="ttdeci">constexpr auto mac(const Acc &amp;acc, const Vec1 &amp;v1, const Vec2 &amp;v2) -&gt; operand_base_type_t&lt; Acc &gt;</div><div class="ttdoc">Returns an accumulator with the element-wise multiply-add of the two input vectors and accumulator.</div><div class="ttdef"><b>Definition</b> aie.hpp:4849</div></div>
</div><!-- fragment --> <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga66a7452722b5ba7fde5575cab45bd98d" id="r_ga66a7452722b5ba7fde5575cab45bd98d"><td class="memTemplParams" colspan="2">template&lt;Elem E&gt; </td></tr>
<tr class="memitem:ga66a7452722b5ba7fde5575cab45bd98d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga66a7452722b5ba7fde5575cab45bd98d">aie::abs</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> &amp;a) -&gt; <a class="el" href="namespaceaie.html#a291ba7a3e8845d534e1320dcda213eee">operand_base_type_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> &gt;</td></tr>
<tr class="memdesc:ga66a7452722b5ba7fde5575cab45bd98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value of a value.  <br /></td></tr>
<tr class="separator:ga66a7452722b5ba7fde5575cab45bd98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17773cd42e9ade49a2b43d7564d28db2" id="r_ga17773cd42e9ade49a2b43d7564d28db2"><td class="memTemplParams" colspan="2">template&lt;Vector Vec&gt; </td></tr>
<tr class="memitem:ga17773cd42e9ade49a2b43d7564d28db2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga17773cd42e9ade49a2b43d7564d28db2">aie::abs</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &gt;</td></tr>
<tr class="memdesc:ga17773cd42e9ade49a2b43d7564d28db2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute value for each element in the given vector.  <br /></td></tr>
<tr class="separator:ga17773cd42e9ade49a2b43d7564d28db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada326bd4667e38eec6a935843154ad83" id="r_gada326bd4667e38eec6a935843154ad83"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TR</a>  = int32, ComplexVector Vec&gt; <br />
requires (Utils::is_one_of_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TR</a>, <a class="el" href="types_8hpp.html#a3271a6f688eb2ba4047a2982ff49919a">int32</a>, <a class="el" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a>&gt;)</td></tr>
<tr class="memitem:gada326bd4667e38eec6a935843154ad83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gada326bd4667e38eec6a935843154ad83">aie::abs_square</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">int</a> shift=0)</td></tr>
<tr class="memdesc:gada326bd4667e38eec6a935843154ad83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute square of each element in the given complex vector.  <br /></td></tr>
<tr class="separator:gada326bd4667e38eec6a935843154ad83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28e40bbb50dd889bb79971660c9b36da" id="r_ga28e40bbb50dd889bb79971660c9b36da"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> Elems&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#a671c2b8e3def407f9379ded985d3e5f5ab8b3a8da1cd5229bb8d392de190b3cb3">arch::AIE</a>) || (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#a671c2b8e3def407f9379ded985d3e5f5ad1eb15b0e4782d2a7bf8b1f7a69cc774">arch::AIE_ML</a>) &amp;&amp; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">__AIE_API_COMPLEX_FP32_EMULATION__</a> == 1))</td></tr>
<tr class="memitem:ga28e40bbb50dd889bb79971660c9b36da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">float</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga28e40bbb50dd889bb79971660c9b36da">aie::abs_square</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">cfloat</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a> &gt; &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>)</td></tr>
<tr class="memdesc:ga28e40bbb50dd889bb79971660c9b36da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the absolute square of each element in the given complex vector.  <br /></td></tr>
<tr class="separator:ga28e40bbb50dd889bb79971660c9b36da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd9f3351ca16d4398e29251c6b903663" id="r_gafd9f3351ca16d4398e29251c6b903663"><td class="memTemplParams" colspan="2">template&lt;AccumOrOp Acc, Vector Vec&gt; <br />
requires (Acc::size() == Vec::size())</td></tr>
<tr class="memitem:gafd9f3351ca16d4398e29251c6b903663"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gafd9f3351ca16d4398e29251c6b903663">aie::add</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>) -&gt; <a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &gt;</td></tr>
<tr class="memdesc:gafd9f3351ca16d4398e29251c6b903663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the element-wise addition of the input accumulator and vector.  <br /></td></tr>
<tr class="separator:gafd9f3351ca16d4398e29251c6b903663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64cd0aa88dbcddf9456f84d788984775" id="r_ga64cd0aa88dbcddf9456f84d788984775"><td class="memTemplParams" colspan="2">template&lt;AccumOrOp Acc, Elem E&gt; </td></tr>
<tr class="memitem:ga64cd0aa88dbcddf9456f84d788984775"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga64cd0aa88dbcddf9456f84d788984775">aie::add</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a) -&gt; <a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &gt;</td></tr>
<tr class="memdesc:ga64cd0aa88dbcddf9456f84d788984775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the addition of a value to all the elements of the input vector.  <br /></td></tr>
<tr class="separator:ga64cd0aa88dbcddf9456f84d788984775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60396818cac5fb4aa6fa590c355889e7" id="r_ga60396818cac5fb4aa6fa590c355889e7"><td class="memTemplParams" colspan="2">template&lt;AccumOrOp Acc1, AccumOrOp Acc2&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>) &amp;&amp; <a class="el" href="namespaceaie.html#a227a4d2ec42f2db90f91165c9f85b670">is_same_accum_v</a>&lt;<a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc1</a>&gt;, <a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc2</a>&gt;&gt;)</td></tr>
<tr class="memitem:ga60396818cac5fb4aa6fa590c355889e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga60396818cac5fb4aa6fa590c355889e7">aie::add</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc1</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc2</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc2</a>) -&gt; <a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc1</a> &gt;</td></tr>
<tr class="memdesc:ga60396818cac5fb4aa6fa590c355889e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the element-wise addition of the two input accumulators.  <br /></td></tr>
<tr class="separator:ga60396818cac5fb4aa6fa590c355889e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a275bd015733f51d2fa25b894f77da9" id="r_ga4a275bd015733f51d2fa25b894f77da9"><td class="memTemplParams" colspan="2">template&lt;Vector Vec, Elem E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;)</td></tr>
<tr class="memitem:ga4a275bd015733f51d2fa25b894f77da9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga4a275bd015733f51d2fa25b894f77da9">aie::add</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &gt;</td></tr>
<tr class="memdesc:ga4a275bd015733f51d2fa25b894f77da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the addition of a value to all the elements of the input vector.  <br /></td></tr>
<tr class="separator:ga4a275bd015733f51d2fa25b894f77da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9617379444e0c56c89d2e46bf3de66df" id="r_ga9617379444e0c56c89d2e46bf3de66df"><td class="memTemplParams" colspan="2">template&lt;Vector Vec1, Vector Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a>&gt;)</td></tr>
<tr class="memitem:ga9617379444e0c56c89d2e46bf3de66df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga9617379444e0c56c89d2e46bf3de66df">aie::add</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &gt;</td></tr>
<tr class="memdesc:ga9617379444e0c56c89d2e46bf3de66df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the element-wise addition of the two input vectors.  <br /></td></tr>
<tr class="separator:ga9617379444e0c56c89d2e46bf3de66df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga960d8e5ec423e7dc654a8e084a2ce5dc" id="r_ga960d8e5ec423e7dc654a8e084a2ce5dc"><td class="memTemplParams" colspan="2">template&lt;Elem E, Vector Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</td></tr>
<tr class="memitem:ga960d8e5ec423e7dc654a8e084a2ce5dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga960d8e5ec423e7dc654a8e084a2ce5dc">aie::add</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &gt;</td></tr>
<tr class="memdesc:ga960d8e5ec423e7dc654a8e084a2ce5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the addition of a value to all the elements of the input vector.  <br /></td></tr>
<tr class="separator:ga960d8e5ec423e7dc654a8e084a2ce5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabecccc7fda6e19bf388d8b5308d1a7d5" id="r_gabecccc7fda6e19bf388d8b5308d1a7d5"><td class="memTemplParams" colspan="2">template&lt;ComplexElem E&gt; </td></tr>
<tr class="memitem:gabecccc7fda6e19bf388d8b5308d1a7d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gabecccc7fda6e19bf388d8b5308d1a7d5">aie::conj</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> &amp;a) -&gt; <a class="el" href="namespaceaie.html#a291ba7a3e8845d534e1320dcda213eee">operand_base_type_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> &gt;</td></tr>
<tr class="memdesc:gabecccc7fda6e19bf388d8b5308d1a7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the conjugate in the given complex value.  <br /></td></tr>
<tr class="separator:gabecccc7fda6e19bf388d8b5308d1a7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab28beb9f93e1156cf163c1b9ba5575ab" id="r_gab28beb9f93e1156cf163c1b9ba5575ab"><td class="memTemplParams" colspan="2">template&lt;ComplexVector Vec&gt; </td></tr>
<tr class="memitem:gab28beb9f93e1156cf163c1b9ba5575ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gab28beb9f93e1156cf163c1b9ba5575ab">aie::conj</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &gt;</td></tr>
<tr class="memdesc:gab28beb9f93e1156cf163c1b9ba5575ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the conjugate for each element in the given vector of complex elements.  <br /></td></tr>
<tr class="separator:gab28beb9f93e1156cf163c1b9ba5575ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabce953d9615890fc35092acbf53491a4" id="r_gabce953d9615890fc35092acbf53491a4"><td class="memTemplParams" colspan="2">template&lt;ComplexVector Vec, ComplexElem E&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#a671c2b8e3def407f9379ded985d3e5f5ab8b3a8da1cd5229bb8d392de190b3cb3">arch::AIE</a>) || (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#a671c2b8e3def407f9379ded985d3e5f5ad1eb15b0e4782d2a7bf8b1f7a69cc774">arch::AIE_ML</a>) &amp;&amp; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">__AIE_API_COMPLEX_FP32_EMULATION__</a> == 1))</td></tr>
<tr class="memitem:gabce953d9615890fc35092acbf53491a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gabce953d9615890fc35092acbf53491a4">aie::div</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> &amp;b) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt; detail::accum_tag_for_mul_types&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, detail::utils::get_complex_component_type_t&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> &gt; &gt;, Vec::size()&gt;</td></tr>
<tr class="memdesc:gabce953d9615890fc35092acbf53491a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quotients of the element-wise division of a complex vector 'a' by a complex scalar 'b'.  <br /></td></tr>
<tr class="separator:gabce953d9615890fc35092acbf53491a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5765047e8e406626d196c2bcf3140577" id="r_ga5765047e8e406626d196c2bcf3140577"><td class="memTemplParams" colspan="2">template&lt;ComplexVector Vec&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#a671c2b8e3def407f9379ded985d3e5f5ab8b3a8da1cd5229bb8d392de190b3cb3">arch::AIE</a>) || (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#a671c2b8e3def407f9379ded985d3e5f5ad1eb15b0e4782d2a7bf8b1f7a69cc774">arch::AIE_ML</a>) &amp;&amp; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">__AIE_API_COMPLEX_FP32_EMULATION__</a> == 1))</td></tr>
<tr class="memitem:ga5765047e8e406626d196c2bcf3140577"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga5765047e8e406626d196c2bcf3140577">aie::div</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;b) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt; detail::accum_tag_for_mul_types&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, detail::utils::get_complex_component_type_t&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type &gt; &gt;, Vec::size()&gt;</td></tr>
<tr class="memdesc:ga5765047e8e406626d196c2bcf3140577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quotients of the element-wise division of two complex vectors 'a' and 'b'.  <br /></td></tr>
<tr class="separator:ga5765047e8e406626d196c2bcf3140577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f21fc73d2593927cf2f95ce56289907" id="r_ga0f21fc73d2593927cf2f95ce56289907"><td class="memTemplParams" colspan="2">template&lt;Vector Vec, RealElem E&gt; <br />
requires ( detail::is_floating_point_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt; &amp;&amp; detail::is_valid_element_type_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt; &amp;&amp; detail::is_floating_point_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;)</td></tr>
<tr class="memitem:ga0f21fc73d2593927cf2f95ce56289907"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga0f21fc73d2593927cf2f95ce56289907">aie::div</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> b) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt; detail::accum_tag_for_mul_types&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> &gt;, Vec::size()&gt;</td></tr>
<tr class="memdesc:ga0f21fc73d2593927cf2f95ce56289907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quotients of the element-wise division of each value of the first input vector by a scalar.  <br /></td></tr>
<tr class="separator:ga0f21fc73d2593927cf2f95ce56289907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ed5682334e846a69966be95f79e29a" id="r_ga55ed5682334e846a69966be95f79e29a"><td class="memTemplParams" colspan="2">template&lt;Vector Vec1, RealVector Vec2&gt; <br />
requires (Vec1::size() == Vec2::size() &amp;&amp; detail::is_floating_point_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec2::value_type&gt;)</td></tr>
<tr class="memitem:ga55ed5682334e846a69966be95f79e29a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga55ed5682334e846a69966be95f79e29a">aie::div</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;b) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt; detail::accum_tag_for_mul_types&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec2::value_type &gt;, Vec1::size()&gt;</td></tr>
<tr class="memdesc:ga55ed5682334e846a69966be95f79e29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quotients of the element-wise division of each value of the first input vector by the corresponding element in the second input vector.  <br /></td></tr>
<tr class="separator:ga55ed5682334e846a69966be95f79e29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5087b78ead5ea47bfd024b3e8d2bc94e" id="r_ga5087b78ead5ea47bfd024b3e8d2bc94e"><td class="memTemplParams" colspan="2">template&lt;AccumOrOp Acc, VectorOrOp Vec, ElemOrOp E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;)</td></tr>
<tr class="memitem:ga5087b78ead5ea47bfd024b3e8d2bc94e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga5087b78ead5ea47bfd024b3e8d2bc94e">aie::mac</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a) -&gt; <a class="el" href="namespaceaie.html#a291ba7a3e8845d534e1320dcda213eee">operand_base_type_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &gt;</td></tr>
<tr class="memdesc:ga5087b78ead5ea47bfd024b3e8d2bc94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the element-wise multiply-add of input vector, value and accumulator.  <br /></td></tr>
<tr class="separator:ga5087b78ead5ea47bfd024b3e8d2bc94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf56db067d71355ecab1b3fd9e406cd55" id="r_gaf56db067d71355ecab1b3fd9e406cd55"><td class="memTemplParams" colspan="2">template&lt;AccumOrOp Acc, VectorOrOp Vec1, VectorOrOp Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec2::value_type&gt;)</td></tr>
<tr class="memitem:gaf56db067d71355ecab1b3fd9e406cd55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gaf56db067d71355ecab1b3fd9e406cd55">aie::mac</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>) -&gt; <a class="el" href="namespaceaie.html#a291ba7a3e8845d534e1320dcda213eee">operand_base_type_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &gt;</td></tr>
<tr class="memdesc:gaf56db067d71355ecab1b3fd9e406cd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the element-wise multiply-add of the two input vectors and accumulator.  <br /></td></tr>
<tr class="separator:gaf56db067d71355ecab1b3fd9e406cd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb01f076fc9e453407c0c310a3f5c5f3" id="r_gadb01f076fc9e453407c0c310a3f5c5f3"><td class="memTemplParams" colspan="2">template&lt;AccumOrOp Acc, ElemOrOp E, VectorOrOp Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</td></tr>
<tr class="memitem:gadb01f076fc9e453407c0c310a3f5c5f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gadb01f076fc9e453407c0c310a3f5c5f3">aie::mac</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>) -&gt; <a class="el" href="namespaceaie.html#a291ba7a3e8845d534e1320dcda213eee">operand_base_type_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &gt;</td></tr>
<tr class="memdesc:gadb01f076fc9e453407c0c310a3f5c5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the element-wise multiply-add of value, input vector and accumulator.  <br /></td></tr>
<tr class="separator:gadb01f076fc9e453407c0c310a3f5c5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1d879a7d4aec4c47cb1183f654a13a" id="r_gaca1d879a7d4aec4c47cb1183f654a13a"><td class="memTemplParams" colspan="2">template&lt;AccumOrOp Acc, Vector Vec&gt; <br />
requires (Vec::size() == Acc::size())</td></tr>
<tr class="memitem:gaca1d879a7d4aec4c47cb1183f654a13a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gaca1d879a7d4aec4c47cb1183f654a13a">aie::mac_square</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>)</td></tr>
<tr class="memdesc:gaca1d879a7d4aec4c47cb1183f654a13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the addition or subtraction of the given accumulator and the element-wise square of the input vector.  <br /></td></tr>
<tr class="separator:gaca1d879a7d4aec4c47cb1183f654a13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga779ed52c430334ad79f05e72c065ea51" id="r_ga779ed52c430334ad79f05e72c065ea51"><td class="memTemplParams" colspan="2">template&lt;Accum Acc, VectorOrOp Vec, ElemOrOp E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;)</td></tr>
<tr class="memitem:ga779ed52c430334ad79f05e72c065ea51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga779ed52c430334ad79f05e72c065ea51">aie::msc</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &gt;</td></tr>
<tr class="memdesc:ga779ed52c430334ad79f05e72c065ea51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the element-wise multiply-add of input vector, value and accumulator.  <br /></td></tr>
<tr class="separator:ga779ed52c430334ad79f05e72c065ea51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf48b0ba593d06066a0383ff1724e599b" id="r_gaf48b0ba593d06066a0383ff1724e599b"><td class="memTemplParams" colspan="2">template&lt;Accum Acc, VectorOrOp Vec1, VectorOrOp Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec2::value_type&gt;)</td></tr>
<tr class="memitem:gaf48b0ba593d06066a0383ff1724e599b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gaf48b0ba593d06066a0383ff1724e599b">aie::msc</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &gt;</td></tr>
<tr class="memdesc:gaf48b0ba593d06066a0383ff1724e599b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the element-wise multiply-add of the two input vectors and accumulator.  <br /></td></tr>
<tr class="separator:gaf48b0ba593d06066a0383ff1724e599b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c2b00e9df3fcbf879dcfd7f8191e6d0" id="r_ga7c2b00e9df3fcbf879dcfd7f8191e6d0"><td class="memTemplParams" colspan="2">template&lt;Accum Acc, ElemOrOp E, VectorOrOp Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</td></tr>
<tr class="memitem:ga7c2b00e9df3fcbf879dcfd7f8191e6d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga7c2b00e9df3fcbf879dcfd7f8191e6d0">aie::msc</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &gt;</td></tr>
<tr class="memdesc:ga7c2b00e9df3fcbf879dcfd7f8191e6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the element-wise multiply-add of value, input vector and accumulator.  <br /></td></tr>
<tr class="separator:ga7c2b00e9df3fcbf879dcfd7f8191e6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f92c1d2705124f60eafd43ea0519a52" id="r_ga7f92c1d2705124f60eafd43ea0519a52"><td class="memTemplParams" colspan="2">template&lt;Accum Acc, Vector Vec&gt; <br />
requires (Vec::size() == Acc::size())</td></tr>
<tr class="memitem:ga7f92c1d2705124f60eafd43ea0519a52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga7f92c1d2705124f60eafd43ea0519a52">aie::msc_square</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>)</td></tr>
<tr class="memdesc:ga7f92c1d2705124f60eafd43ea0519a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the subtraction of the given accumulator and the element-wise square of the input vector.  <br /></td></tr>
<tr class="separator:ga7f92c1d2705124f60eafd43ea0519a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdca71673bdae6c6642b88dab9aee1fe" id="r_gafdca71673bdae6c6642b88dab9aee1fe"><td class="memTemplParams" colspan="2">template&lt;VectorOrOp Vec, ElemOrOp E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;)</td></tr>
<tr class="memitem:gafdca71673bdae6c6642b88dab9aee1fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gafdca71673bdae6c6642b88dab9aee1fe">aie::mul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a)</td></tr>
<tr class="memdesc:gafdca71673bdae6c6642b88dab9aee1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the element-wise multiplication of a value and all the elements of a vector.  <br /></td></tr>
<tr class="separator:gafdca71673bdae6c6642b88dab9aee1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac41b20273656eb670a3bf765c666b099" id="r_gac41b20273656eb670a3bf765c666b099"><td class="memTemplParams" colspan="2">template&lt;AccumElemBaseType AccumTag, VectorOrOp Vec, ElemOrOp E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;)</td></tr>
<tr class="memitem:gac41b20273656eb670a3bf765c666b099"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gac41b20273656eb670a3bf765c666b099">aie::mul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a>, Vec::size()&gt;</td></tr>
<tr class="memdesc:gac41b20273656eb670a3bf765c666b099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator of the requested type with the element-wise multiplication of a value and all the elements of the input vector.  <br /></td></tr>
<tr class="separator:gac41b20273656eb670a3bf765c666b099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad702e06db25d29fb4805b5d531959bd4" id="r_gad702e06db25d29fb4805b5d531959bd4"><td class="memTemplParams" colspan="2">template&lt;VectorOrOp Vec1, VectorOrOp Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec2::value_type&gt;)</td></tr>
<tr class="memitem:gad702e06db25d29fb4805b5d531959bd4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gad702e06db25d29fb4805b5d531959bd4">aie::mul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>)</td></tr>
<tr class="memdesc:gad702e06db25d29fb4805b5d531959bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the element-wise multiplication of the two input vectors.  <br /></td></tr>
<tr class="separator:gad702e06db25d29fb4805b5d531959bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7ff4236ae3cbc544f118df14881ee4e" id="r_gac7ff4236ae3cbc544f118df14881ee4e"><td class="memTemplParams" colspan="2">template&lt;AccumElemBaseType AccumTag, VectorOrOp Vec1, VectorOrOp Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec2::value_type&gt;)</td></tr>
<tr class="memitem:gac7ff4236ae3cbc544f118df14881ee4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gac7ff4236ae3cbc544f118df14881ee4e">aie::mul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a>, Vec1::size()&gt;</td></tr>
<tr class="memdesc:gac7ff4236ae3cbc544f118df14881ee4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator of the requested type with the element-wise multiplication of the two input vectors.  <br /></td></tr>
<tr class="separator:gac7ff4236ae3cbc544f118df14881ee4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e8e3d8b11c0cce9298997d2d84e97ac" id="r_ga3e8e3d8b11c0cce9298997d2d84e97ac"><td class="memTemplParams" colspan="2">template&lt;ElemOrOp E, VectorOrOp Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</td></tr>
<tr class="memitem:ga3e8e3d8b11c0cce9298997d2d84e97ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga3e8e3d8b11c0cce9298997d2d84e97ac">aie::mul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>)</td></tr>
<tr class="memdesc:ga3e8e3d8b11c0cce9298997d2d84e97ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the element-wise multiplication of a value and all the elements of a vector.  <br /></td></tr>
<tr class="separator:ga3e8e3d8b11c0cce9298997d2d84e97ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb18c8f730a8df605a2f483f6642a6b" id="r_gaccb18c8f730a8df605a2f483f6642a6b"><td class="memTemplParams" colspan="2">template&lt;AccumElemBaseType AccumTag, ElemOrOp E, VectorOrOp Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</td></tr>
<tr class="memitem:gaccb18c8f730a8df605a2f483f6642a6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gaccb18c8f730a8df605a2f483f6642a6b">aie::mul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a>, Vec::size()&gt;</td></tr>
<tr class="memdesc:gaccb18c8f730a8df605a2f483f6642a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator of the requested type with the element-wise multiplication of a value and all the elements of the input vector.  <br /></td></tr>
<tr class="separator:gaccb18c8f730a8df605a2f483f6642a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ded1a3f13df7d68d98471b0d7460319" id="r_ga9ded1a3f13df7d68d98471b0d7460319"><td class="memTemplParams" colspan="2">template&lt;Vector Vec&gt; </td></tr>
<tr class="memitem:ga9ded1a3f13df7d68d98471b0d7460319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga9ded1a3f13df7d68d98471b0d7460319">aie::mul_square</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>)</td></tr>
<tr class="memdesc:ga9ded1a3f13df7d68d98471b0d7460319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the element-wise square of the input vector.  <br /></td></tr>
<tr class="separator:ga9ded1a3f13df7d68d98471b0d7460319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c49cf4cbc1a4749ecd6f2736baff27a" id="r_ga4c49cf4cbc1a4749ecd6f2736baff27a"><td class="memTemplParams" colspan="2">template&lt;AccumElemBaseType AccumTag, Vector Vec&gt; </td></tr>
<tr class="memitem:ga4c49cf4cbc1a4749ecd6f2736baff27a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga4c49cf4cbc1a4749ecd6f2736baff27a">aie::mul_square</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a>, Vec::size()&gt;</td></tr>
<tr class="memdesc:ga4c49cf4cbc1a4749ecd6f2736baff27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator of the requested type with the element-wise square of the input vector.  <br /></td></tr>
<tr class="separator:ga4c49cf4cbc1a4749ecd6f2736baff27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eb0056c5f146d013b0c1df7fd10b193" id="r_ga3eb0056c5f146d013b0c1df7fd10b193"><td class="memTemplParams" colspan="2">template&lt;Accum Acc&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>))</td></tr>
<tr class="memitem:ga3eb0056c5f146d013b0c1df7fd10b193"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga3eb0056c5f146d013b0c1df7fd10b193">aie::neg</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &gt;</td></tr>
<tr class="memdesc:ga3eb0056c5f146d013b0c1df7fd10b193"><td class="mdescLeft">&#160;</td><td class="mdescRight">For accumulators, return an accumulator whose elements are the same as in the given accumulator but with the sign flipped.  <br /></td></tr>
<tr class="separator:ga3eb0056c5f146d013b0c1df7fd10b193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab179b6c69b23831efaede37942f4f40b" id="r_gab179b6c69b23831efaede37942f4f40b"><td class="memTemplParams" colspan="2">template&lt;Elem E&gt; </td></tr>
<tr class="memitem:gab179b6c69b23831efaede37942f4f40b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gab179b6c69b23831efaede37942f4f40b">aie::neg</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> &amp;a) -&gt; <a class="el" href="namespaceaie.html#a291ba7a3e8845d534e1320dcda213eee">operand_base_type_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> &gt;</td></tr>
<tr class="memdesc:gab179b6c69b23831efaede37942f4f40b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For values with signed types, return the input value with the sign flipped.  <br /></td></tr>
<tr class="separator:gab179b6c69b23831efaede37942f4f40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac4acce9273fc84e7b8bcc7c90c2507" id="r_ga0ac4acce9273fc84e7b8bcc7c90c2507"><td class="memTemplParams" colspan="2">template&lt;Vector Vec&gt; </td></tr>
<tr class="memitem:ga0ac4acce9273fc84e7b8bcc7c90c2507"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga0ac4acce9273fc84e7b8bcc7c90c2507">aie::neg</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &gt;</td></tr>
<tr class="memdesc:ga0ac4acce9273fc84e7b8bcc7c90c2507"><td class="mdescLeft">&#160;</td><td class="mdescRight">For vectors with signed types, return a vector whose elements are the same as in the given vector but with the sign flipped.  <br /></td></tr>
<tr class="separator:ga0ac4acce9273fc84e7b8bcc7c90c2507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab92bbb99da7f9e9f508b295ff4e8a22f" id="r_gab92bbb99da7f9e9f508b295ff4e8a22f"><td class="memTemplParams" colspan="2">template&lt;VectorOrOp Vec, ElemOrOp E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;)</td></tr>
<tr class="memitem:gab92bbb99da7f9e9f508b295ff4e8a22f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gab92bbb99da7f9e9f508b295ff4e8a22f">aie::negmul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a)</td></tr>
<tr class="memdesc:gab92bbb99da7f9e9f508b295ff4e8a22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the negate of the element-wise multiplication of all the elements of the input vector and a value.  <br /></td></tr>
<tr class="separator:gab92bbb99da7f9e9f508b295ff4e8a22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6bcf475802b2878c7219f704fe5966e" id="r_gae6bcf475802b2878c7219f704fe5966e"><td class="memTemplParams" colspan="2">template&lt;AccumElemBaseType AccumTag, VectorOrOp Vec, ElemOrOp E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;)</td></tr>
<tr class="memitem:gae6bcf475802b2878c7219f704fe5966e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gae6bcf475802b2878c7219f704fe5966e">aie::negmul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a>, Vec::size()&gt;</td></tr>
<tr class="memdesc:gae6bcf475802b2878c7219f704fe5966e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator of the requested type with the negate of the element-wise multiplication of all the elements of the input vector and a value.  <br /></td></tr>
<tr class="separator:gae6bcf475802b2878c7219f704fe5966e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada4f0fabe822e66f5a3595381529dd7d" id="r_gada4f0fabe822e66f5a3595381529dd7d"><td class="memTemplParams" colspan="2">template&lt;VectorOrOp Vec1, VectorOrOp Vec2&gt; <br />
requires ((Vec1::size() == Vec2::size()) &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec2::value_type&gt;)</td></tr>
<tr class="memitem:gada4f0fabe822e66f5a3595381529dd7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gada4f0fabe822e66f5a3595381529dd7d">aie::negmul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>)</td></tr>
<tr class="memdesc:gada4f0fabe822e66f5a3595381529dd7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the negate of the element-wise multiplication of the two input vectors.  <br /></td></tr>
<tr class="separator:gada4f0fabe822e66f5a3595381529dd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57f32feffa761285534612c08cb9cf28" id="r_ga57f32feffa761285534612c08cb9cf28"><td class="memTemplParams" colspan="2">template&lt;AccumElemBaseType AccumTag, VectorOrOp Vec1, VectorOrOp Vec2&gt; <br />
requires (Vec1::size() == Vec2::size() &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec2::value_type&gt;)</td></tr>
<tr class="memitem:ga57f32feffa761285534612c08cb9cf28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga57f32feffa761285534612c08cb9cf28">aie::negmul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a>, Vec1::size()&gt;</td></tr>
<tr class="memdesc:ga57f32feffa761285534612c08cb9cf28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator of the requested type with the negate of the element-wise multiplication of the two input vectors.  <br /></td></tr>
<tr class="separator:ga57f32feffa761285534612c08cb9cf28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86c0d05f2433090fe2694ce64338ebe3" id="r_ga86c0d05f2433090fe2694ce64338ebe3"><td class="memTemplParams" colspan="2">template&lt;ElemOrOp E, VectorOrOp Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</td></tr>
<tr class="memitem:ga86c0d05f2433090fe2694ce64338ebe3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga86c0d05f2433090fe2694ce64338ebe3">aie::negmul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>)</td></tr>
<tr class="memdesc:ga86c0d05f2433090fe2694ce64338ebe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the negate of the element-wise multiplication of a value and all the elements of the input vector.  <br /></td></tr>
<tr class="separator:ga86c0d05f2433090fe2694ce64338ebe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e94a615906595c0a0f04d6b1627702" id="r_ga60e94a615906595c0a0f04d6b1627702"><td class="memTemplParams" colspan="2">template&lt;AccumElemBaseType AccumTag, ElemOrOp E, VectorOrOp Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</td></tr>
<tr class="memitem:ga60e94a615906595c0a0f04d6b1627702"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga60e94a615906595c0a0f04d6b1627702">aie::negmul</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>) -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a>, Vec::size()&gt;</td></tr>
<tr class="memdesc:ga60e94a615906595c0a0f04d6b1627702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator of the requested type with the negate of the element-wise multiplication of a value and all the elements of the input vector.  <br /></td></tr>
<tr class="separator:ga60e94a615906595c0a0f04d6b1627702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga166fc9c040171f9bbd7f4a2d642e968d" id="r_ga166fc9c040171f9bbd7f4a2d642e968d"><td class="memTemplParams" colspan="2">template&lt;Vector Vec, Vector... Others&gt; </td></tr>
<tr class="memitem:ga166fc9c040171f9bbd7f4a2d642e968d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga166fc9c040171f9bbd7f4a2d642e968d">aie::reduce_add_v</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Others</a> &amp;... <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">others</a>) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &gt;</td></tr>
<tr class="memdesc:ga166fc9c040171f9bbd7f4a2d642e968d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sums of the elements in the input vectors.  <br /></td></tr>
<tr class="separator:ga166fc9c040171f9bbd7f4a2d642e968d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbb15dfcef33748e99531b9db0654ef9" id="r_gacbb15dfcef33748e99531b9db0654ef9"><td class="memTemplParams" colspan="2">template&lt;Vector Vec, Elem E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</td></tr>
<tr class="memitem:gacbb15dfcef33748e99531b9db0654ef9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gacbb15dfcef33748e99531b9db0654ef9">aie::saturating_add</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &gt;</td></tr>
<tr class="memdesc:gacbb15dfcef33748e99531b9db0654ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the addition of a value to all the elements of the input vector.  <br /></td></tr>
<tr class="separator:gacbb15dfcef33748e99531b9db0654ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabad8a8fbfba2b1d3838eddc55584dce7" id="r_gabad8a8fbfba2b1d3838eddc55584dce7"><td class="memTemplParams" colspan="2">template&lt;Vector Vec1, Vector Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a>&gt; &amp;&amp; !detail::is_floating_point_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type&gt;)</td></tr>
<tr class="memitem:gabad8a8fbfba2b1d3838eddc55584dce7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gabad8a8fbfba2b1d3838eddc55584dce7">aie::saturating_add</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &gt;</td></tr>
<tr class="memdesc:gabad8a8fbfba2b1d3838eddc55584dce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the element-wise addition of the two input vectors.  <br /></td></tr>
<tr class="separator:gabad8a8fbfba2b1d3838eddc55584dce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92cefad730d530b74e0bf3856ffd94d4" id="r_ga92cefad730d530b74e0bf3856ffd94d4"><td class="memTemplParams" colspan="2">template&lt;Elem E, Vector Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</td></tr>
<tr class="memitem:ga92cefad730d530b74e0bf3856ffd94d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga92cefad730d530b74e0bf3856ffd94d4">aie::saturating_add</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &gt;</td></tr>
<tr class="memdesc:ga92cefad730d530b74e0bf3856ffd94d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the addition of a value to all the elements of the input vector.  <br /></td></tr>
<tr class="separator:ga92cefad730d530b74e0bf3856ffd94d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40be3c751f693f5357bb68ffd66231b3" id="r_ga40be3c751f693f5357bb68ffd66231b3"><td class="memTemplParams" colspan="2">template&lt;Vector Vec, Elem E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</td></tr>
<tr class="memitem:ga40be3c751f693f5357bb68ffd66231b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga40be3c751f693f5357bb68ffd66231b3">aie::saturating_sub</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &gt;</td></tr>
<tr class="memdesc:ga40be3c751f693f5357bb68ffd66231b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the subtraction of the elements of the input vector and a value.  <br /></td></tr>
<tr class="separator:ga40be3c751f693f5357bb68ffd66231b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cbff5c7c9e805d504613fa9ee04efe5" id="r_ga7cbff5c7c9e805d504613fa9ee04efe5"><td class="memTemplParams" colspan="2">template&lt;Vector Vec1, Vector Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a>&gt; &amp;&amp; !detail::is_floating_point_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type&gt;)</td></tr>
<tr class="memitem:ga7cbff5c7c9e805d504613fa9ee04efe5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga7cbff5c7c9e805d504613fa9ee04efe5">aie::saturating_sub</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &gt;</td></tr>
<tr class="memdesc:ga7cbff5c7c9e805d504613fa9ee04efe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the element-wise subtraction of the two input vectors.  <br /></td></tr>
<tr class="separator:ga7cbff5c7c9e805d504613fa9ee04efe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbac55376c863a1329f58e8bca8d2328" id="r_gabbac55376c863a1329f58e8bca8d2328"><td class="memTemplParams" colspan="2">template&lt;Elem E, Vector Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</td></tr>
<tr class="memitem:gabbac55376c863a1329f58e8bca8d2328"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gabbac55376c863a1329f58e8bca8d2328">aie::saturating_sub</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &gt;</td></tr>
<tr class="memdesc:gabbac55376c863a1329f58e8bca8d2328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the subtraction of a value to all the elements of the input vector.  <br /></td></tr>
<tr class="separator:gabbac55376c863a1329f58e8bca8d2328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac64f0d27ae9232e90665cf122c9cc9c8" id="r_gac64f0d27ae9232e90665cf122c9cc9c8"><td class="memTemplParams" colspan="2">template&lt;AccumOrOp Acc, Vector Vec&gt; <br />
requires (Acc::size() == Vec::size())</td></tr>
<tr class="memitem:gac64f0d27ae9232e90665cf122c9cc9c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gac64f0d27ae9232e90665cf122c9cc9c8">aie::sub</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>) -&gt; <a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &gt;</td></tr>
<tr class="memdesc:gac64f0d27ae9232e90665cf122c9cc9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the element-wise subtraction of the input accumulator and vector.  <br /></td></tr>
<tr class="separator:gac64f0d27ae9232e90665cf122c9cc9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cb4643c18fa8c9e4af5bd5b66027501" id="r_ga6cb4643c18fa8c9e4af5bd5b66027501"><td class="memTemplParams" colspan="2">template&lt;AccumOrOp Acc, Elem E&gt; </td></tr>
<tr class="memitem:ga6cb4643c18fa8c9e4af5bd5b66027501"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga6cb4643c18fa8c9e4af5bd5b66027501">aie::sub</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a) -&gt; <a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &gt;</td></tr>
<tr class="memdesc:ga6cb4643c18fa8c9e4af5bd5b66027501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the subtraction of all the elements of the input accumulator and a value.  <br /></td></tr>
<tr class="separator:ga6cb4643c18fa8c9e4af5bd5b66027501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8df76bdd7baa067ec4f908e71378134e" id="r_ga8df76bdd7baa067ec4f908e71378134e"><td class="memTemplParams" colspan="2">template&lt;AccumOrOp Acc1, AccumOrOp Acc2&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>) &amp;&amp; <a class="el" href="namespaceaie.html#a227a4d2ec42f2db90f91165c9f85b670">is_same_accum_v</a>&lt;<a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc1</a>&gt;, <a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc2</a>&gt;&gt;)</td></tr>
<tr class="memitem:ga8df76bdd7baa067ec4f908e71378134e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga8df76bdd7baa067ec4f908e71378134e">aie::sub</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc1</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc2</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc2</a>) -&gt; <a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc1</a> &gt;</td></tr>
<tr class="memdesc:ga8df76bdd7baa067ec4f908e71378134e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an accumulator with the element-wise subtraction of the two input accumulators.  <br /></td></tr>
<tr class="separator:ga8df76bdd7baa067ec4f908e71378134e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2c6cadaf8d63f0eb7dc8259aebc8e08" id="r_gae2c6cadaf8d63f0eb7dc8259aebc8e08"><td class="memTemplParams" colspan="2">template&lt;Vector Vec, Elem E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</td></tr>
<tr class="memitem:gae2c6cadaf8d63f0eb7dc8259aebc8e08"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gae2c6cadaf8d63f0eb7dc8259aebc8e08">aie::sub</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &gt;</td></tr>
<tr class="memdesc:gae2c6cadaf8d63f0eb7dc8259aebc8e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the subtraction of the elements of the input vector and a value.  <br /></td></tr>
<tr class="separator:gae2c6cadaf8d63f0eb7dc8259aebc8e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa937a70d9aa0bc2949378899eecb30e" id="r_gafa937a70d9aa0bc2949378899eecb30e"><td class="memTemplParams" colspan="2">template&lt;Vector Vec1, Vector Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a>&gt;)</td></tr>
<tr class="memitem:gafa937a70d9aa0bc2949378899eecb30e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#gafa937a70d9aa0bc2949378899eecb30e">aie::sub</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &gt;</td></tr>
<tr class="memdesc:gafa937a70d9aa0bc2949378899eecb30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the element-wise subtraction of the two input vectors.  <br /></td></tr>
<tr class="separator:gafa937a70d9aa0bc2949378899eecb30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ab90d0e095c7c62b226d6566fde9279" id="r_ga3ab90d0e095c7c62b226d6566fde9279"><td class="memTemplParams" colspan="2">template&lt;Elem E, Vector Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</td></tr>
<tr class="memitem:ga3ab90d0e095c7c62b226d6566fde9279"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__group__arithmetic.html#ga3ab90d0e095c7c62b226d6566fde9279">aie::sub</a> (<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> a, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>) -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &gt;</td></tr>
<tr class="memdesc:ga3ab90d0e095c7c62b226d6566fde9279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with the subtraction of a value and all the elements of the input vector.  <br /></td></tr>
<tr class="separator:ga3ab90d0e095c7c62b226d6566fde9279"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga66a7452722b5ba7fde5575cab45bd98d" name="ga66a7452722b5ba7fde5575cab45bd98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66a7452722b5ba7fde5575cab45bd98d">&#9670;&#160;</a></span>abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Elem E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceaie.html#a291ba7a3e8845d534e1320dcda213eee">operand_base_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the absolute value of a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga17773cd42e9ade49a2b43d7564d28db2" name="ga17773cd42e9ade49a2b43d7564d28db2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17773cd42e9ade49a2b43d7564d28db2">&#9670;&#160;</a></span>abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the absolute value for each element in the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada326bd4667e38eec6a935843154ad83" name="gada326bd4667e38eec6a935843154ad83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada326bd4667e38eec6a935843154ad83">&#9670;&#160;</a></span>abs_square() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TR</a>  = int32, ComplexVector Vec&gt; <br />
requires (Utils::is_one_of_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">TR</a>, <a class="el" href="types_8hpp.html#a3271a6f688eb2ba4047a2982ff49919a">int32</a>, <a class="el" href="types_8hpp.html#aa918a75369e273ba410b034cd2ced87b">int16</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::abs_square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">int</a>&#160;</td>
          <td class="paramname"><em>shift</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the absolute square of each element in the given complex vector. </p>
<p>For a vector of N complex elements, returns a vector of N integers </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>].<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">real²</a> + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>].<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">imag²</a>;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input complex vector </td></tr>
    <tr><td class="paramname">shift</td><td>Optional parameter to control the shift value used in the srs internally</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TR</td><td>Type of returned integer vector, default to int32 but can be set to int16 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga28e40bbb50dd889bb79971660c9b36da" name="ga28e40bbb50dd889bb79971660c9b36da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28e40bbb50dd889bb79971660c9b36da">&#9670;&#160;</a></span>abs_square() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">unsigned</a> Elems&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#a671c2b8e3def407f9379ded985d3e5f5ab8b3a8da1cd5229bb8d392de190b3cb3">arch::AIE</a>) || (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#a671c2b8e3def407f9379ded985d3e5f5ad1eb15b0e4782d2a7bf8b1f7a69cc774">arch::AIE_ML</a>) &amp;&amp; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">__AIE_API_COMPLEX_FP32_EMULATION__</a> == 1))</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">float</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a> &gt; aie::abs_square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="group__group__basic__types.html#classaie_1_1vector">vector</a>&lt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">cfloat</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the absolute square of each element in the given complex vector. </p>
<p>For a vector of N complex elements, returns a vector of N integers </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>].<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">real²</a> + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>].<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">imag²</a>;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input complex vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd9f3351ca16d4398e29251c6b903663" name="gafd9f3351ca16d4398e29251c6b903663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd9f3351ca16d4398e29251c6b903663">&#9670;&#160;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumOrOp Acc, Vector Vec&gt; <br />
requires (Acc::size() == Vec::size())</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an accumulator with the element-wise addition of the input accumulator and vector. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Input accumulator </td></tr>
    <tr><td class="paramname">v</td><td>Input vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga64cd0aa88dbcddf9456f84d788984775" name="ga64cd0aa88dbcddf9456f84d788984775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64cd0aa88dbcddf9456f84d788984775">&#9670;&#160;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumOrOp Acc, Elem E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an accumulator with the addition of a value to all the elements of the input vector. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] + a;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Input accumulator </td></tr>
    <tr><td class="paramname">a</td><td>Value. The type must meet <a class="el" href="conceptaie_1_1Elem.html">aie::Elem</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga60396818cac5fb4aa6fa590c355889e7" name="ga60396818cac5fb4aa6fa590c355889e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60396818cac5fb4aa6fa590c355889e7">&#9670;&#160;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumOrOp Acc1, AccumOrOp Acc2&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>) &amp;&amp; <a class="el" href="namespaceaie.html#a227a4d2ec42f2db90f91165c9f85b670">is_same_accum_v</a>&lt;<a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc1</a>&gt;, <a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc2</a>&gt;&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc1</a> &amp;&#160;</td>
          <td class="paramname"><em>acc1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc2</a> &amp;&#160;</td>
          <td class="paramname"><em>acc2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc1</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an accumulator with the element-wise addition of the two input accumulators. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc1</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc2</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc1</td><td>First input accumulator. The type must meet <a class="el" href="conceptaie_1_1AccumOrOp.html">aie::AccumOrOp</a>. </td></tr>
    <tr><td class="paramname">acc2</td><td>Second input accumulator. The type must meet <a class="el" href="conceptaie_1_1AccumOrOp.html">aie::AccumOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4a275bd015733f51d2fa25b894f77da9" name="ga4a275bd015733f51d2fa25b894f77da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a275bd015733f51d2fa25b894f77da9">&#9670;&#160;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec, Elem E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with the addition of a value to all the elements of the input vector. </p>
<p>The type of the value and the type of the vector elements must be the same.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] + a;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">a</td><td>Value. The type must meet <a class="el" href="conceptaie_1_1Elem.html">aie::Elem</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9617379444e0c56c89d2e46bf3de66df" name="ga9617379444e0c56c89d2e46bf3de66df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9617379444e0c56c89d2e46bf3de66df">&#9670;&#160;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec1, Vector Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a>&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with the element-wise addition of the two input vectors. </p>
<p>The vectors must have the same type and size.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">v2</td><td>Second input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga960d8e5ec423e7dc654a8e084a2ce5dc" name="ga960d8e5ec423e7dc654a8e084a2ce5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga960d8e5ec423e7dc654a8e084a2ce5dc">&#9670;&#160;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Elem E, Vector Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with the addition of a value to all the elements of the input vector. </p>
<p>The type of the value and the type of the vector elements must be the same.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = a + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value. The type must meet <a class="el" href="conceptaie_1_1Elem.html">aie::Elem</a>. </td></tr>
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabecccc7fda6e19bf388d8b5308d1a7d5" name="gabecccc7fda6e19bf388d8b5308d1a7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabecccc7fda6e19bf388d8b5308d1a7d5">&#9670;&#160;</a></span>conj() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ComplexElem E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::conj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceaie.html#a291ba7a3e8845d534e1320dcda213eee">operand_base_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the conjugate in the given complex value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab28beb9f93e1156cf163c1b9ba5575ab" name="gab28beb9f93e1156cf163c1b9ba5575ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab28beb9f93e1156cf163c1b9ba5575ab">&#9670;&#160;</a></span>conj() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ComplexVector Vec&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::conj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the conjugate for each element in the given vector of complex elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabce953d9615890fc35092acbf53491a4" name="gabce953d9615890fc35092acbf53491a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabce953d9615890fc35092acbf53491a4">&#9670;&#160;</a></span>div() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ComplexVector Vec, ComplexElem E&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#a671c2b8e3def407f9379ded985d3e5f5ab8b3a8da1cd5229bb8d392de190b3cb3">arch::AIE</a>) || (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#a671c2b8e3def407f9379ded985d3e5f5ad1eb15b0e4782d2a7bf8b1f7a69cc774">arch::AIE_ML</a>) &amp;&amp; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">__AIE_API_COMPLEX_FP32_EMULATION__</a> == 1))</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt;detail::accum_tag_for_mul_types&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, detail::utils::get_complex_component_type_t&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;&gt;,
        Vec::size()&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the quotients of the element-wise division of a complex vector 'a' by a complex scalar 'b'. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = a[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] / b;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Vector of dividends. The type must meet <a class="el" href="conceptaie_1_1ComplexVector.html">aie::ComplexVector</a>. </td></tr>
    <tr><td class="paramname">b</td><td>Divisor. The type must meet <a class="el" href="conceptaie_1_1ComplexElem.html">aie::ComplexElem</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5765047e8e406626d196c2bcf3140577" name="ga5765047e8e406626d196c2bcf3140577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5765047e8e406626d196c2bcf3140577">&#9670;&#160;</a></span>div() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ComplexVector Vec&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#a671c2b8e3def407f9379ded985d3e5f5ab8b3a8da1cd5229bb8d392de190b3cb3">arch::AIE</a>) || (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#a671c2b8e3def407f9379ded985d3e5f5ad1eb15b0e4782d2a7bf8b1f7a69cc774">arch::AIE_ML</a>) &amp;&amp; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">__AIE_API_COMPLEX_FP32_EMULATION__</a> == 1))</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt;
    detail::accum_tag_for_mul_types&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, detail::utils::get_complex_component_type_t&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;&gt;,
    Vec::size()&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the quotients of the element-wise division of two complex vectors 'a' and 'b'. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = a[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] / b[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><p>Complex division is achieved by multiplying both dividend and divisor by the conjugate of the divisor:</p>
<div class="fragment"><div class="line">a = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">A</a> + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Bi</a>; b = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">C</a> + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Di</a></div>
<div class="line">a/b = (<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">A</a> + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Bi</a>) / (<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">C</a> + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Di</a>) = ((<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">A</a> + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Bi</a>) * (<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">C</a> - <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Di</a>)) / ((<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">C</a> + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Di</a>) * (<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">C</a> - <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Di</a>))</div>
<div class="line">    = ((<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">A</a> + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Bi</a>) * (<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">C</a> - <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Di</a>)) /  (<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">C</a>^2 + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">D</a>^2)</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Vector of dividends. The type must meet <a class="el" href="conceptaie_1_1ComplexVector.html">aie::ComplexVector</a>. </td></tr>
    <tr><td class="paramname">b</td><td>Vector of divisors. The type must meet <a class="el" href="conceptaie_1_1ComplexVector.html">aie::ComplexVector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f21fc73d2593927cf2f95ce56289907" name="ga0f21fc73d2593927cf2f95ce56289907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f21fc73d2593927cf2f95ce56289907">&#9670;&#160;</a></span>div() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec, RealElem E&gt; <br />
requires ( detail::is_floating_point_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt; &amp;&amp; detail::is_valid_element_type_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt; &amp;&amp; detail::is_floating_point_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt;detail::accum_tag_for_mul_types&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;, Vec::size()&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the quotients of the element-wise division of each value of the first input vector by a scalar. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = a[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] / b;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Vector of dividends. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">b</td><td>Divisor. The type must meet <a class="el" href="conceptaie_1_1RealElem.html">aie::RealElem</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga55ed5682334e846a69966be95f79e29a" name="ga55ed5682334e846a69966be95f79e29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55ed5682334e846a69966be95f79e29a">&#9670;&#160;</a></span>div() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec1, RealVector Vec2&gt; <br />
requires (Vec1::size() == Vec2::size() &amp;&amp; detail::is_floating_point_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec2::value_type&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::div </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt;detail::accum_tag_for_mul_types&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec2::value_type&gt;, Vec1::size()&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the quotients of the element-wise division of each value of the first input vector by the corresponding element in the second input vector. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = a[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] / b[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Vector of dividends. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">b</td><td>Vector of divisors. The type must meet <a class="el" href="conceptaie_1_1RealVector.html">aie::RealVector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5087b78ead5ea47bfd024b3e8d2bc94e" name="ga5087b78ead5ea47bfd024b3e8d2bc94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5087b78ead5ea47bfd024b3e8d2bc94e">&#9670;&#160;</a></span>mac() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumOrOp Acc, VectorOrOp Vec, ElemOrOp E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::mac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a291ba7a3e8845d534e1320dcda213eee">operand_base_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator with the element-wise multiply-add of input vector, value and accumulator. </p>
<p>The vector and the accumulator must have the same size and the types of all operands must be compatible. Operands can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(a);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accumulator to which the result of the multiplication is added (or subtracted). The type must meet AccumOrOp. </td></tr>
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
    <tr><td class="paramname">a</td><td>Input value. The type must meet <a class="el" href="conceptaie_1_1ElemOrOp.html">aie::ElemOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf56db067d71355ecab1b3fd9e406cd55" name="gaf56db067d71355ecab1b3fd9e406cd55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf56db067d71355ecab1b3fd9e406cd55">&#9670;&#160;</a></span>mac() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumOrOp Acc, VectorOrOp Vec1, VectorOrOp Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec2::value_type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::mac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a291ba7a3e8845d534e1320dcda213eee">operand_base_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator with the element-wise multiply-add of the two input vectors and accumulator. </p>
<p>The vectors and the accumulator must have the same size and their types must be compatible. Operands can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accumulator to which the result of the multiplication is added (or subtracted). The type must meet AccumOrOp. </td></tr>
    <tr><td class="paramname">v1</td><td>First input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
    <tr><td class="paramname">v2</td><td>Second input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb01f076fc9e453407c0c310a3f5c5f3" name="gadb01f076fc9e453407c0c310a3f5c5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb01f076fc9e453407c0c310a3f5c5f3">&#9670;&#160;</a></span>mac() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumOrOp Acc, ElemOrOp E, VectorOrOp Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::mac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a291ba7a3e8845d534e1320dcda213eee">operand_base_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator with the element-wise multiply-add of value, input vector and accumulator. </p>
<p>The vector and the accumulator must have the same size and the types of all operands must be compatible. Operands can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(a) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accumulator to which the result of the multiplication is added (or subtracted). The type must meet AccumOrOp. </td></tr>
    <tr><td class="paramname">a</td><td>Input value. The type must meet <a class="el" href="conceptaie_1_1ElemOrOp.html">aie::ElemOrOp</a>. </td></tr>
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca1d879a7d4aec4c47cb1183f654a13a" name="gaca1d879a7d4aec4c47cb1183f654a13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca1d879a7d4aec4c47cb1183f654a13a">&#9670;&#160;</a></span>mac_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumOrOp Acc, Vector Vec&gt; <br />
requires (Vec::size() == Acc::size())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::mac_square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator with the addition or subtraction of the given accumulator and the element-wise square of the input vector. </p>
<p>The vector and the accumulator must have the same size and their types must be compatible.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Input accumulator. The type must meet <a class="el" href="conceptaie_1_1AccumOrOp.html">aie::AccumOrOp</a>. </td></tr>
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga779ed52c430334ad79f05e72c065ea51" name="ga779ed52c430334ad79f05e72c065ea51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga779ed52c430334ad79f05e72c065ea51">&#9670;&#160;</a></span>msc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Accum Acc, VectorOrOp Vec, ElemOrOp E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::msc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator with the element-wise multiply-add of input vector, value and accumulator. </p>
<p>The vector and the accumulator must have the same size and their types must be compatible. Operands can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] - <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(a);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accumulator from which the result of the multiplication is subtracted. The type must meet <a class="el" href="conceptaie_1_1Accum.html">aie::Accum</a>. </td></tr>
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
    <tr><td class="paramname">a</td><td>Input value. The type must meet <a class="el" href="conceptaie_1_1ElemOrOp.html">aie::ElemOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf48b0ba593d06066a0383ff1724e599b" name="gaf48b0ba593d06066a0383ff1724e599b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf48b0ba593d06066a0383ff1724e599b">&#9670;&#160;</a></span>msc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Accum Acc, VectorOrOp Vec1, VectorOrOp Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec2::value_type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::msc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator with the element-wise multiply-add of the two input vectors and accumulator. </p>
<p>The vectors and the accumulator must have the same size and the types of all operands must be compatible. Operands can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] - <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accumulator from which the result of the multiplication is subtracted. The type must meet <a class="el" href="conceptaie_1_1Accum.html">aie::Accum</a>. </td></tr>
    <tr><td class="paramname">v1</td><td>First input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
    <tr><td class="paramname">v2</td><td>Second input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c2b00e9df3fcbf879dcfd7f8191e6d0" name="ga7c2b00e9df3fcbf879dcfd7f8191e6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c2b00e9df3fcbf879dcfd7f8191e6d0">&#9670;&#160;</a></span>msc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Accum Acc, ElemOrOp E, VectorOrOp Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::msc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator with the element-wise multiply-add of value, input vector and accumulator. </p>
<p>The vector and the accumulator must have the same size and their types must be compatible. Operands can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] - <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(a) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Accumulator from which the result of the multiplication is subtracted. The type must meet <a class="el" href="conceptaie_1_1Accum.html">aie::Accum</a>. </td></tr>
    <tr><td class="paramname">a</td><td>Input value. The type must meet <a class="el" href="conceptaie_1_1ElemOrOp.html">aie::ElemOrOp</a>. </td></tr>
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f92c1d2705124f60eafd43ea0519a52" name="ga7f92c1d2705124f60eafd43ea0519a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f92c1d2705124f60eafd43ea0519a52">&#9670;&#160;</a></span>msc_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Accum Acc, Vector Vec&gt; <br />
requires (Vec::size() == Acc::size())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::msc_square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator with the subtraction of the given accumulator and the element-wise square of the input vector. </p>
<p>The vector and the accumulator must have the same size and their types must be compatible.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] - <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Input accumulator. The type must meet <a class="el" href="conceptaie_1_1Accum.html">aie::Accum</a>. </td></tr>
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafdca71673bdae6c6642b88dab9aee1fe" name="gafdca71673bdae6c6642b88dab9aee1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdca71673bdae6c6642b88dab9aee1fe">&#9670;&#160;</a></span>mul() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VectorOrOp Vec, ElemOrOp E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator with the element-wise multiplication of a value and all the elements of a vector. </p>
<p>The default accumulator accuracy is used of the input vector. The type of the value and the type of the vector elements must be compatible. Operands can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(a);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value. The type must meet <a class="el" href="conceptaie_1_1ElemOrOp.html">aie::ElemOrOp</a>. </td></tr>
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac41b20273656eb670a3bf765c666b099" name="gac41b20273656eb670a3bf765c666b099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac41b20273656eb670a3bf765c666b099">&#9670;&#160;</a></span>mul() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumElemBaseType AccumTag, VectorOrOp Vec, ElemOrOp E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a>, Vec::size()&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator of the requested type with the element-wise multiplication of a value and all the elements of the input vector. </p>
<p>The type of the value and the type of the vector elements must be compatible. Operands can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(a);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AccumTag</td><td>Accumulator tag that specifies the required accumulation bits. The class must be compatible with the vector types (real/complex). Refer to <a class="el" href="group__group__arithmetic.html#DefaultAccumTag">default accumulator tag</a> table for the minimum accumulator element tag required for each combination of input element types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
    <tr><td class="paramname">a</td><td>Value. The type must meet <a class="el" href="conceptaie_1_1ElemOrOp.html">aie::ElemOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad702e06db25d29fb4805b5d531959bd4" name="gad702e06db25d29fb4805b5d531959bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad702e06db25d29fb4805b5d531959bd4">&#9670;&#160;</a></span>mul() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VectorOrOp Vec1, VectorOrOp Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec2::value_type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator with the element-wise multiplication of the two input vectors. </p>
<p>The default accumulator accuracy is used. The vectors must have the same size and compatible types. Operands can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
    <tr><td class="paramname">v2</td><td>Second input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac7ff4236ae3cbc544f118df14881ee4e" name="gac7ff4236ae3cbc544f118df14881ee4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7ff4236ae3cbc544f118df14881ee4e">&#9670;&#160;</a></span>mul() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumElemBaseType AccumTag, VectorOrOp Vec1, VectorOrOp Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec2::value_type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a>, Vec1::size()&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator of the requested type with the element-wise multiplication of the two input vectors. </p>
<p>The vectors must have the same size and compatible types. Vectors can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AccumTag</td><td>Accumulator tag that specifies the required accumulation bits. The class must be compatible with the vector types (real/complex). Refer to <a class="el" href="group__group__arithmetic.html#DefaultAccumTag">default accumulator tag</a> table for the minimum accumulator element tag required for each combination of input element types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
    <tr><td class="paramname">v2</td><td>Second input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3e8e3d8b11c0cce9298997d2d84e97ac" name="ga3e8e3d8b11c0cce9298997d2d84e97ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e8e3d8b11c0cce9298997d2d84e97ac">&#9670;&#160;</a></span>mul() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ElemOrOp E, VectorOrOp Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator with the element-wise multiplication of a value and all the elements of a vector. </p>
<p>The default accumulator accuracy is used of the input vector. The type of the value and the type of the vector elements must be compatible. Operands can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(a) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value. The type must meet <a class="el" href="conceptaie_1_1ElemOrOp.html">aie::ElemOrOp</a>. </td></tr>
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaccb18c8f730a8df605a2f483f6642a6b" name="gaccb18c8f730a8df605a2f483f6642a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccb18c8f730a8df605a2f483f6642a6b">&#9670;&#160;</a></span>mul() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumElemBaseType AccumTag, ElemOrOp E, VectorOrOp Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a8281632124dfc12d000a3823d2636506">is_valid_size_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt; &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::mul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a>, Vec::size()&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator of the requested type with the element-wise multiplication of a value and all the elements of the input vector. </p>
<p>The type of the value and the type of the vector elements must be compatible. Operands can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(a) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AccumTag</td><td>Accumulator tag that specifies the required accumulation bits. The class must be compatible with the vector types (real/complex). Refer to <a class="el" href="group__group__arithmetic.html#DefaultAccumTag">default accumulator tag</a> table for the minimum accumulator element tag required for each combination of input element types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value. The type must meet <a class="el" href="conceptaie_1_1ElemOrOp.html">aie::ElemOrOp</a>. </td></tr>
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9ded1a3f13df7d68d98471b0d7460319" name="ga9ded1a3f13df7d68d98471b0d7460319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ded1a3f13df7d68d98471b0d7460319">&#9670;&#160;</a></span>mul_square() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::mul_square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator with the element-wise square of the input vector. </p>
<p>The default accumulator accuracy is used.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c49cf4cbc1a4749ecd6f2736baff27a" name="ga4c49cf4cbc1a4749ecd6f2736baff27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c49cf4cbc1a4749ecd6f2736baff27a">&#9670;&#160;</a></span>mul_square() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumElemBaseType AccumTag, Vector Vec&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::mul_square </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a>, Vec::size()&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator of the requested type with the element-wise square of the input vector. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AccumTag</td><td>Accumulator tag that specifies the required accumulation bits. The class must be compatible with the vector types (real/complex). Refer to <a class="el" href="group__group__arithmetic.html#DefaultAccumTag">default accumulator tag</a> table for the minimum accumulator element tag required for each combination of input element types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3eb0056c5f146d013b0c1df7fd10b193" name="ga3eb0056c5f146d013b0c1df7fd10b193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eb0056c5f146d013b0c1df7fd10b193">&#9670;&#160;</a></span>neg() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Accum Acc&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>))</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::neg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For accumulators, return an accumulator whose elements are the same as in the given accumulator but with the sign flipped. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Input accumulator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab179b6c69b23831efaede37942f4f40b" name="gab179b6c69b23831efaede37942f4f40b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab179b6c69b23831efaede37942f4f40b">&#9670;&#160;</a></span>neg() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Elem E&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::neg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceaie.html#a291ba7a3e8845d534e1320dcda213eee">operand_base_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For values with signed types, return the input value with the sign flipped. </p>
<p>If the input type is unsigned, the input value is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Input value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0ac4acce9273fc84e7b8bcc7c90c2507" name="ga0ac4acce9273fc84e7b8bcc7c90c2507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ac4acce9273fc84e7b8bcc7c90c2507">&#9670;&#160;</a></span>neg() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::neg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For vectors with signed types, return a vector whose elements are the same as in the given vector but with the sign flipped. </p>
<p>If the input type is unsigned, the input vector is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab92bbb99da7f9e9f508b295ff4e8a22f" name="gab92bbb99da7f9e9f508b295ff4e8a22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab92bbb99da7f9e9f508b295ff4e8a22f">&#9670;&#160;</a></span>negmul() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VectorOrOp Vec, ElemOrOp E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::negmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator with the negate of the element-wise multiplication of all the elements of the input vector and a value. </p>
<p>The default accumulator accuracy is used. The vectors must have the same size and compatible types. Operands can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = -(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(a)));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
    <tr><td class="paramname">a</td><td>Value. The type must meet <a class="el" href="conceptaie_1_1ElemOrOp.html">aie::ElemOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae6bcf475802b2878c7219f704fe5966e" name="gae6bcf475802b2878c7219f704fe5966e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6bcf475802b2878c7219f704fe5966e">&#9670;&#160;</a></span>negmul() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumElemBaseType AccumTag, VectorOrOp Vec, ElemOrOp E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::negmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a>, Vec::size()&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator of the requested type with the negate of the element-wise multiplication of all the elements of the input vector and a value. </p>
<p>The type of the value and the type of the vector elements must be compatible. The input arguments can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = -(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(a));</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AccumTag</td><td>Accumulator tag that specifies the required accumulation bits. The class must be compatible with the vector types (real/complex). Refer to <a class="el" href="group__group__arithmetic.html#DefaultAccumTag">default accumulator tag</a> table for the minimum accumulator element tag required for each combination of input element types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
    <tr><td class="paramname">a</td><td>Value. The type must meet <a class="el" href="conceptaie_1_1ElemOrOp.html">aie::ElemOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada4f0fabe822e66f5a3595381529dd7d" name="gada4f0fabe822e66f5a3595381529dd7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada4f0fabe822e66f5a3595381529dd7d">&#9670;&#160;</a></span>negmul() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VectorOrOp Vec1, VectorOrOp Vec2&gt; <br />
requires ((Vec1::size() == Vec2::size()) &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec2::value_type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::negmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator with the negate of the element-wise multiplication of the two input vectors. </p>
<p>The default accumulator accuracy is used. The vectors must have the same size and compatible types. Operands can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = -(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
    <tr><td class="paramname">v2</td><td>Second input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga57f32feffa761285534612c08cb9cf28" name="ga57f32feffa761285534612c08cb9cf28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57f32feffa761285534612c08cb9cf28">&#9670;&#160;</a></span>negmul() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumElemBaseType AccumTag, VectorOrOp Vec1, VectorOrOp Vec2&gt; <br />
requires (Vec1::size() == Vec2::size() &amp;&amp; <a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec2::value_type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::negmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a>, Vec1::size()&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator of the requested type with the negate of the element-wise multiplication of the two input vectors. </p>
<p>The vectors must have the same size and compatible types. Vectors can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = -(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]));</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AccumTag</td><td>Accumulator tag that specifies the required accumulation bits. The class must be compatible with the vector types (real/complex). Refer to <a class="el" href="group__group__arithmetic.html#DefaultAccumTag">default accumulator tag</a> table for the minimum accumulator element tag required for each combination of input element types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
    <tr><td class="paramname">v2</td><td>Second input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86c0d05f2433090fe2694ce64338ebe3" name="ga86c0d05f2433090fe2694ce64338ebe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86c0d05f2433090fe2694ce64338ebe3">&#9670;&#160;</a></span>negmul() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ElemOrOp E, VectorOrOp Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::negmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator with the negate of the element-wise multiplication of a value and all the elements of the input vector. </p>
<p>The default accumulator accuracy is used. The vectors must have the same size and compatible types. Operands can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = -(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(a) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]));</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value. The type must meet <a class="el" href="conceptaie_1_1ElemOrOp.html">aie::ElemOrOp</a>. </td></tr>
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga60e94a615906595c0a0f04d6b1627702" name="ga60e94a615906595c0a0f04d6b1627702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60e94a615906595c0a0f04d6b1627702">&#9670;&#160;</a></span>negmul() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumElemBaseType AccumTag, ElemOrOp E, VectorOrOp Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a506a03520764ed2b689c3850dfb2bb41">is_valid_mul_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::negmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__group__basic__types.html#classaie_1_1accum">accum</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">AccumTag</a>, Vec::size()&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator of the requested type with the negate of the element-wise multiplication of a value and all the elements of the input vector. </p>
<p>The type of the value and the type of the vector elements must be compatible. The input arguments can also be lazy operations (see <a class="el" href="group__group__basic__types__ops.html">Lazy Operations</a>). On some AIE architectures certain operations can be collapsed with the multiplication into a single instruction.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = -(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op1</a>(a) * <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">op2</a>(<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>]));</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AccumTag</td><td>Accumulator tag that specifies the required accumulation bits. The class must be compatible with the vector types (real/complex). Refer to <a class="el" href="group__group__arithmetic.html#DefaultAccumTag">default accumulator tag</a> table for the minimum accumulator element tag required for each combination of input element types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value. The type must meet <a class="el" href="conceptaie_1_1ElemOrOp.html">aie::ElemOrOp</a>. </td></tr>
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1VectorOrOp.html">aie::VectorOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga166fc9c040171f9bbd7f4a2d642e968d" name="ga166fc9c040171f9bbd7f4a2d642e968d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga166fc9c040171f9bbd7f4a2d642e968d">&#9670;&#160;</a></span>reduce_add_v()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec, Vector... Others&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::reduce_add_v </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Others</a> &amp;...&#160;</td>
          <td class="paramname"><em>others</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the sums of the elements in the input vectors. </p>
<p>The sum of each input vector is stored in an element of the output vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>First input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">others</td><td>Remaining input vectors. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacbb15dfcef33748e99531b9db0654ef9" name="gacbb15dfcef33748e99531b9db0654ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbb15dfcef33748e99531b9db0654ef9">&#9670;&#160;</a></span>saturating_add() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec, Elem E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::saturating_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with the addition of a value to all the elements of the input vector. </p>
<p>The behaviour of the addition is dictated by the saturation mode The type of the value and the type of the vector elements must be the same.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] + a;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">a</td><td>Value. The type must meet <a class="el" href="conceptaie_1_1Elem.html">aie::Elem</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabad8a8fbfba2b1d3838eddc55584dce7" name="gabad8a8fbfba2b1d3838eddc55584dce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabad8a8fbfba2b1d3838eddc55584dce7">&#9670;&#160;</a></span>saturating_add() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec1, Vector Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a>&gt; &amp;&amp; !detail::is_floating_point_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::saturating_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with the element-wise addition of the two input vectors. </p>
<p>The behaviour of the addition is dictated by the saturation mode The vectors must have the same type and size.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">v2</td><td>Second input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92cefad730d530b74e0bf3856ffd94d4" name="ga92cefad730d530b74e0bf3856ffd94d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92cefad730d530b74e0bf3856ffd94d4">&#9670;&#160;</a></span>saturating_add() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Elem E, Vector Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::saturating_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with the addition of a value to all the elements of the input vector. </p>
<p>The behaviour of the addition is dictated by the saturation mode The type of the value and the type of the vector elements must be the same.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = a + <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value. The type must meet <a class="el" href="conceptaie_1_1Elem.html">aie::Elem</a>. </td></tr>
    <tr><td class="paramname">v</td><td>Input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga40be3c751f693f5357bb68ffd66231b3" name="ga40be3c751f693f5357bb68ffd66231b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40be3c751f693f5357bb68ffd66231b3">&#9670;&#160;</a></span>saturating_sub() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec, Elem E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::saturating_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with the subtraction of the elements of the input vector and a value. </p>
<p>The behaviour of the subtraction is dictated by the saturation mode The type of the value and the type of the vector elements must be the same.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] - a;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector (subtrahend). The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">a</td><td>Value (minuend). The type must meet <a class="el" href="conceptaie_1_1Elem.html">aie::Elem</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7cbff5c7c9e805d504613fa9ee04efe5" name="ga7cbff5c7c9e805d504613fa9ee04efe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cbff5c7c9e805d504613fa9ee04efe5">&#9670;&#160;</a></span>saturating_sub() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec1, Vector Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a>&gt; &amp;&amp; !detail::is_floating_point_v&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec1::value_type&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::saturating_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with the element-wise subtraction of the two input vectors. </p>
<p>The behaviour of the subtraction is dictated by the saturation mode The vectors must have the same type and size.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] - <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">v2</td><td>Second input vector. The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabbac55376c863a1329f58e8bca8d2328" name="gabbac55376c863a1329f58e8bca8d2328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbac55376c863a1329f58e8bca8d2328">&#9670;&#160;</a></span>saturating_sub() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Elem E, Vector Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::saturating_sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with the subtraction of a value to all the elements of the input vector. </p>
<p>The behaviour of the subtraction is dictated by the saturation mode The type of the value and the type of the vector elements must be the same.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = a - <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value (minuend). The type must meet <a class="el" href="conceptaie_1_1Elem.html">aie::Elem</a>. </td></tr>
    <tr><td class="paramname">v</td><td>Input vector (subtrahend). The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac64f0d27ae9232e90665cf122c9cc9c8" name="gac64f0d27ae9232e90665cf122c9cc9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac64f0d27ae9232e90665cf122c9cc9c8">&#9670;&#160;</a></span>sub() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumOrOp Acc, Vector Vec&gt; <br />
requires (Acc::size() == Vec::size())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">constexpr</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an accumulator with the element-wise subtraction of the input accumulator and vector. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] - <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Input accumulator (minuend) </td></tr>
    <tr><td class="paramname">v</td><td>Input vector (subtrahend) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6cb4643c18fa8c9e4af5bd5b66027501" name="ga6cb4643c18fa8c9e4af5bd5b66027501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cb4643c18fa8c9e4af5bd5b66027501">&#9670;&#160;</a></span>sub() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumOrOp Acc, Elem E&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a> &amp;&#160;</td>
          <td class="paramname"><em>acc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an accumulator with the subtraction of all the elements of the input accumulator and a value. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] - a;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc</td><td>Input accumulator (minuend) </td></tr>
    <tr><td class="paramname">a</td><td>Value (subtrahend). The type must meet <a class="el" href="conceptaie_1_1Elem.html">aie::Elem</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8df76bdd7baa067ec4f908e71378134e" name="ga8df76bdd7baa067ec4f908e71378134e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8df76bdd7baa067ec4f908e71378134e">&#9670;&#160;</a></span>sub() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;AccumOrOp Acc1, AccumOrOp Acc2&gt; <br />
requires (<a class="el" href="group__group__utility__functions.html#a625fe645add467b5e19e60195bcc971a">arch::is</a>(<a class="el" href="group__group__utility__functions.html#ac2cdece807dd8a3785a30a968bf89892aa82d89a380c790b126450e584e106179">arch::Gen2</a>) &amp;&amp; <a class="el" href="namespaceaie.html#a227a4d2ec42f2db90f91165c9f85b670">is_same_accum_v</a>&lt;<a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc1</a>&gt;, <a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc2</a>&gt;&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc1</a> &amp;&#160;</td>
          <td class="paramname"><em>acc1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc2</a> &amp;&#160;</td>
          <td class="paramname"><em>acc2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#ab7a68a2a1d91eaa4bc2e967d75dbc614">result_type_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Acc1</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an accumulator with the element-wise subtraction of the two input accumulators. </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc1</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] - <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">acc2</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acc1</td><td>First input accumulator. The type must meet <a class="el" href="conceptaie_1_1AccumOrOp.html">aie::AccumOrOp</a>. </td></tr>
    <tr><td class="paramname">acc2</td><td>Second input accumulator. The type must meet <a class="el" href="conceptaie_1_1AccumOrOp.html">aie::AccumOrOp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae2c6cadaf8d63f0eb7dc8259aebc8e08" name="gae2c6cadaf8d63f0eb7dc8259aebc8e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2c6cadaf8d63f0eb7dc8259aebc8e08">&#9670;&#160;</a></span>sub() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec, Elem E&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with the subtraction of the elements of the input vector and a value. </p>
<p>The type of the value and the type of the vector elements must be the same.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] - a;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Input vector (subtrahend). The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">a</td><td>Value (minuend). The type must meet <a class="el" href="conceptaie_1_1Elem.html">aie::Elem</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafa937a70d9aa0bc2949378899eecb30e" name="gafa937a70d9aa0bc2949378899eecb30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa937a70d9aa0bc2949378899eecb30e">&#9670;&#160;</a></span>sub() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Vector Vec1, Vector Vec2&gt; <br />
requires (<a class="el" href="namespaceaie.html#a4aeecaeb33bbf13108f02dcec54b29cb">is_same_vector_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a>&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec1</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with the element-wise subtraction of the two input vectors. </p>
<p>The vectors must have the same type and size.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v1</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] - <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v2</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>First input vector (minuend). The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
    <tr><td class="paramname">v2</td><td>Second input vector (subtrahend). The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ab90d0e095c7c62b226d6566fde9279" name="ga3ab90d0e095c7c62b226d6566fde9279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ab90d0e095c7c62b226d6566fde9279">&#9670;&#160;</a></span>sub() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Elem E, Vector Vec&gt; <br />
requires (<a class="el" href="namespaceaie.html#a33e8eaf5b5498a9e56eb727132ebe882">is_valid_elem_op_v</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>, <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">typename</a> Vec::value_type&gt;)</div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">auto</a> aie::sub </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">E</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">const</a> <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">aie_dm_resource_remove_t</a>&lt;<a class="el" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Vec</a>&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector with the subtraction of a value and all the elements of the input vector. </p>
<p>The type of the value and the type of the vector elements must be the same.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> = 0; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a> &lt; <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">Elems</a>; ++<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>)</div>
<div class="line">    <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">out</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>] = a - <a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">v</a>[<a class="code hl_typedef" href="namespaceaie.html#a43a139787b463ec1b70e6d1e25621808">i</a>];</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Value (minuend). The type must meet <a class="el" href="conceptaie_1_1Elem.html">aie::Elem</a>. </td></tr>
    <tr><td class="paramname">v</td><td>Input vector (subtrahend). The type must meet <a class="el" href="conceptaie_1_1Vector.html">aie::Vector</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- SPDX-License-Identifier: MIT -->
<!-- Copyright (C) 2022 Xilinx, Inc. -->
<!-- Copyright (C) 2022-2024 Advanced Micro Devices, Inc. -->
<!-- HTML footer for doxygen 1.9.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">UG1529 &copy; 2024 Advanced Micro Devices, Inc. All rights reserved.</li>
  </ul>
</div>
</body>
</html>
